<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>遗传算法详解</title>
      <link href="/2021/11/13/yi-chuan-suan-fa-xiang-jie/"/>
      <url>/2021/11/13/yi-chuan-suan-fa-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="遗传算法原理">遗传算法原理</h1><h2 id="背景介绍">1 背景介绍</h2><p>进化计算：繁殖、变异、竞争、选择</p><h2 id="基本遗传算法定义">2 基本遗传算法定义</h2><p><strong>种群（population）：</strong> 种群是指用遗传算法求解问题时，初始给定的多个解的集合</p><p><strong>个体（individual）：</strong> 个体是指种群中的单个元素，它通常由一个用于描述其基本遗传结构的数据结构来表示</p><p><strong>染色体（chromos）：</strong> 染色体是指对个体编码后所得到的编码串，染色体的每一位称为基因，染色体上由若干个基因构成一个有效信息段称为基因组</p><p><strong>适应度函数（fitness）：</strong> 适应度函数是一种用来对种群中个体的环境适应性进行度量的函数。其函数值是遗传算法实现优胜略汰的主要依据</p><p><strong>遗传操作（genetic operator）：</strong> 遗传操作是指用于种群而产生新的种群的操作，标准的遗传操作包括以下三种基本形式：</p><ul><li>选择（selection）</li><li>交叉（crossover）</li><li>变异（mutation）</li></ul><figure><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919104604553.png" alt="image-20210919104604553"><figcaption aria-hidden="true">image-20210919104604553</figcaption></figure><h2 id="基本遗传算法的方法">3 基本遗传算法的方法</h2><h3 id="个体数m的选取">个体数M的选取</h3><ul><li><strong>M</strong> 越大，个体的多样性越高，但运行效率变低</li><li><strong>M</strong>越小，可提高算法的运行速度，但个体的多样性变差</li><li>一般在 <strong>10~20</strong></li></ul><h3 id="个体编码">个体编码</h3><h4 id="二进制编码">二进制编码</h4><h5 id="编码方法">编码方法</h5><p><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919105225848.png" alt="image-20210919105225848" style="zoom:67%;"></p><p>将最小值对应二进制的最小值，将最大值对应二进制最大值，也就是二进制长度-1</p><h5 id="编码精度和编码长度">编码精度和编码长度</h5><p><span class="math display">\[\delta = \frac{U_{max} - U_{min}}{2^l-1} \\\rightarrow l \geq log_{2}(\frac{U_{max} - U_{min}}{\delta}+1)\]</span></p><p><span class="math inline">\(\delta\)</span> 是想要的编码精度，就是得到小数点后几位</p><p><span class="math inline">\(l\)</span> 是需要的二进制编码的长度</p><p><span class="math inline">\(U\)</span> 是数据的范围</p><h4 id="格雷编码">格雷编码</h4><p>格雷码属于可靠性编码，是一种错误最小的编码方式。编码串之间只有一位差异，对应的参数值也只是微小的差别，相当于提高了遗传算法的局部搜索能力</p><figure><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919110859048.png" alt="image-20210919110859048"><figcaption aria-hidden="true">image-20210919110859048</figcaption></figure><h5 id="格雷码的特性">格雷码的特性</h5><ul><li>格雷码是一种变权码，==每一位码没有固定大小==（位数不同会造成编码顺序不同），很难直接进行比较大小和算术运算，常用到与二进制码之间的转换</li><li>格雷码的十进制数奇偶性与其码字中1的个数的奇偶性相同</li></ul><h5 id="格雷码的递归生成规则">格雷码的递归生成规则</h5><ol type="1"><li>1位格雷码有两个码字（0和1）</li><li>（n+1）位格雷码中前 <span class="math inline">\(2^n\)</span> 个码字等于n位的格雷码的码字，按顺序书写，加前缀0</li><li>（n+1）位格雷码中后 <span class="math inline">\(2^n\)</span> 个码字等于n位的格雷码的码字，按逆序书写，加前缀0</li><li>（n+1）位格雷码集合 = n位格雷码集合（顺序）加前缀0 + n位格雷码集合（逆序）加前缀1</li></ol><h5 id="格雷码与二进制码之间的转换">格雷码与二进制码之间的转换</h5><p>n位二进制码 <span class="math inline">\(\rightarrow\)</span> n位格雷码（编码）</p><ul><li>对n位二进制码字，从右到左，以0到n-1编号</li><li>如果二进制码字第i位和i+1位相同，则对应的格雷码的第i位为0，否则为1</li><li>当i+1=n时，二进制的第n位被认定为0，即n-1位不变</li></ul><p><span class="math display">\[G_i = B_i \oplus B_{i+1} (n-1 \geq i \geq 1)\]</span></p><p>n位格雷码 <span class="math inline">\(\rightarrow\)</span> n位二进制（解码）</p><p>从左边第二位起，将每位与左边一位解码后的值异或，作为该位解码后的值（最左边一位依然不变） <span class="math display">\[B_i = G_i \oplus B_{i+1}(n-1 \geq i \geq 1)\]</span></p><h4 id="浮点数编码">浮点数编码</h4><p>直接使用实数进行编码，也叫做真值编码</p><h4 id="符号编码">符号编码</h4><p>染色体编码串中的基因值取自一个无数值含义，只有代码含义的符号集</p><p><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919114127420.png" alt="image-20210919114127420" style="zoom:33%;"></p><p>但是在交叉和变异操作时需要特别的设计</p><h3 id="适应度函数">适应度函数</h3><p>适应度：个体在进化过程中有可能达到或接近最优解的优良程度</p><p>适应度函数：度量个体适应度的函数，也称为待解决问题的目标函数值</p><h4 id="适应度的尺度变化">适应度的尺度变化</h4><h5 id="线性变换">线性变换</h5><p>保证适应度为非负 <span class="math display">\[f' = \alpha f + \beta \\\alpha = \frac{f_{avg}}{f_{avg}-f_{min}} \\\beta = \frac{f_{min}f_{avg}}{f_{avg}-f_{min}}\]</span> <span class="math inline">\(f_{avg}\)</span> 为集合的平均值，<span class="math inline">\(f_{min}\)</span> 为集合的平均值</p><h5 id="非线性变换">非线性变换</h5><ul><li><p>幂函数变换法： <span class="math display">\[f' = f^{k}\]</span></p></li><li><p>指数函数变换法 <span class="math display">\[f'=e^{-\alpha f}\]</span></p></li><li><p>对数函数变换法 <span class="math display">\[f'=logf\]</span></p></li></ul><h3 id="选择">选择</h3><p>根据个体的适应度及其分布，确定在下一代中被选择的概率</p><h4 id="轮盘赌选择法">轮盘赌选择法</h4><p>产生 <span class="math inline">\([0,1]\)</span> 之间的随机数，作为选择指针来确定被选个体，其适应度必须为正</p><p>通过适应度函数的大小来确定每一个个体被选择的概率，再将这些概率划分为区间称为累计概率，以便随机数进行选择</p><figure><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919143753167.png" alt="image-20210919143753167"><figcaption aria-hidden="true">image-20210919143753167</figcaption></figure><h4 id="竞标赛选择法">竞标赛选择法</h4><p>随机挑选一定数目的个体，然后将最好的个体选择出来</p><p>这样做的结果就是最差的那个个体必定会被淘汰</p><h4 id="排序选择法">排序选择法</h4><p>对群体中的所有个体按其适应度大小进行降序排序，基于这个排序来分配各个个体被选中的概率</p><p>适应度可正可负</p><p>概率人为确定，与适应度无关</p><h4 id="最佳个体保存法">最佳个体保存法</h4><ul><li>群体中适应度最高的个体不进行交叉和变异操作，而直接复制下一代</li><li>可使最优解不被破坏，也可能收敛到局部最优解</li><li>通常与前面的方法共同使用</li></ul><p>•种群中出现个别适应度相当高的个体时，会导致其在种群中快速繁殖，使算法快速收敛到局部最优解。</p><p>•当个体的适应度彼此非常接近时，且交叉后的个体变化不大，容易使进化过程陷于停顿，难以找到最优解。</p><p>•解决思路之一：适应度尺度变换。</p><h3 id="交叉">交叉</h3><p>按照某种方式对选择的父代个体的染色体的部分基因进行交配重组，从而形成新的个体</p><h4 id="二进制交叉">二进制交叉</h4><h5 id="单点交叉">单点交叉</h5><p>随机选择一个交点 <span class="math inline">\(o\)</span> ，交叉概率一般取值较大，大概在 <strong>0.4~0.99</strong></p><p>交叉概率大太会破坏优良个体，太小会导致产生的速度过慢</p><h5 id="多点交叉">多点交叉</h5><p>选择多个单点进行交叉</p><h5 id="随机交叉">随机交叉</h5><p>对个体的每一个基因随机选择交叉与否</p><h4 id="实值交叉">实值交叉</h4><p>有父代个体 <span class="math inline">\(X_1,X_2\)</span> ，则它们产生的后代个体 <span class="math inline">\(Y_1,Y_2\)</span> 为： <span class="math display">\[\left \{\begin {array}{rcl}Y_1 = \alpha X_1 + (1 - \alpha)X_2 \\Y_2 = \alpha X_2 + (1 - \alpha)X_1\end{array}\right.\]</span></p><h3 id="变异">变异</h3><p>对选中个体的染色体中的某些基因进行变动，以形成新的个体。</p><h4 id="二进制变异">二进制变异</h4><p>变异概率 <span class="math inline">\(P_m\)</span> 一般取值较小，为<strong>0.0001~0.1</strong></p><p>变异概率太大会破坏优良个体，太小新个体的产生速度过慢</p><h4 id="实值变异">实值变异</h4><p><span class="math display">\[Y =U_{min}+\alpha \times (U_{min}-U_{max})\]</span></p><p><span class="math inline">\(\alpha\)</span> 可以服从均匀分布或者高斯分布</p><h4 id="终止代数">终止代数</h4><ul><li>进化计算运行到指定代数就终止，一般为<strong>50~1000</strong></li><li>连续几代的平均适应度的差异小于指定阈值</li></ul><h3 id="参数讨论">参数讨论</h3><p><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919150304169.png" alt="image-20210919150304169" style="zoom:50%;"></p><h2 id="改进遗传算法">4 改进遗传算法</h2><h3 id="分层遗传算法">分层遗传算法</h3><p>基本思想：模拟生物进化过程中的基因隔离和基因迁移，各子群之间既有相对的封闭性，又有必要的交流和沟通</p><ul><li>随机生成 <span class="math inline">\(N \times n\)</span> 个样本，将它们分成 <span class="math inline">\(N\)</span> 个子种群，每个子种群包含 <span class="math inline">\(n\)</span> 个样本</li><li>每个子群独自运行各自的遗传算法</li><li>记录每个种群的平均适应度</li><li>根据适应度进行种群间个体的遗传操作</li><li>重复第二步，直到收敛条件借宿</li></ul><p>特点：</p><ul><li>子群中：基本遗传算法</li><li>子群间：交叉、变异</li><li>分布式并行</li></ul><h3 id="混合遗传算法">混合遗传算法</h3><p>与模拟退火算法结合‘</p><p>遗传过程的特点：</p><ul><li>前期，个体适应度差异较大，容易淘汰</li><li>后期：个体间适应度差异较小，容易停滞</li></ul><p>模拟退火的作用：适应度缩放</p><ul><li>前期：减小个体间的差异</li><li>后期：增大个体间的差异</li></ul><p>适应度变换公式 <span class="math display">\[f'_{i} = \frac{e^{\frac{f_i}{T}}}{\sum_{i=1}^{M}e^{\frac{f_i}{T}}}T = T_0(A^{g-1})\]</span> <span class="math inline">\(M\)</span> 为种群大小，<span class="math inline">\(f_i\)</span> 为第 <span class="math inline">\(i\)</span> 个个体的适应度，<span class="math inline">\(g\)</span> 为遗传代数，<span class="math inline">\(T\)</span> 为温度，<span class="math inline">\(T_0\)</span> 为初始温度，<span class="math inline">\(A\)</span> 为退火速度</p><h3 id="自适应遗传算法">自适应遗传算法</h3><p>交叉和变异的概率随适应度自动改变</p><ul><li>群体适应度趋于一致，增加交叉和变异的概率</li><li>群体适应度比较分散，减少交叉和变异概率、</li><li>适应度高于平均适应度的个体，减少交叉和变异概率，予以保护</li><li>适应度低于平均适应度的个体，增加交叉和变异概率，使其淘汰</li></ul><figure><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919163601845.png" alt="image-20210919163601845"><figcaption aria-hidden="true">image-20210919163601845</figcaption></figure><h3 id="原对偶遗传算法">原对偶遗传算法</h3><p><strong>Primal-dual GA(PDGA)</strong>, 解决动态优化问题，目标函数随环境等改变而变化</p><p>定义原染色体和对偶染色体</p><ul><li>原-对偶染色体定义为某个距离空间内距离最大的一对染色体</li><li>在某种条件下将原染色体用其对偶染色体替代</li><li>采用<strong>Hamming</strong>距离定义<strong>PDM</strong>函数<ul><li><strong>Hamming</strong>：两个染色体对应基因位点的值不同的基因个数</li></ul></li><li>在一对原对偶染色体中，如果对偶染色体优于原染色体，则这样的映射为有效映射，否则为无效映射</li></ul><p><strong>PDGA</strong>算法流程：</p><ol type="1"><li>采用常规操作产生中间中间种群 <span class="math inline">\(P(t)\)</span></li><li>从 <span class="math inline">\(P(t)\)</span> 中选择一定数量个体 <span class="math inline">\(D(t)\)</span> ，并计算他们的对偶染色体</li><li>对于 <span class="math inline">\(D(t)\)</span> 中的个体 <span class="math inline">\(x\)</span> ，如果其对偶染色体适应度更大，则 <span class="math inline">\(x\)</span> 被其对偶染色体取代，否则保留</li></ol><p>优势：只有有效的PDM运算才能够使好的对偶染色体有机会传递到下一代，这既有助于增强种群多样性，保持探索能力，又不会影响当前种群的迭代过程，保持种群的利用能力</p><h4 id="改进方法">改进方法</h4><p>在基本算法中，一对原对偶染色体基因型截然相反，在种群进化后期，大多数染色体都分布在适应值较大区域，其对偶染色体适应值较低，因此大多数PDM运算都会失效，因此难以产生多样性和最好的解，但却会浪费计算资源。如果环境的变化较小，这样过于“强烈”的PDM运算不会明显改善算法性能</p><p>并不让染色体中每一位基因都参与PDM运算，而是按概率决定是否参与运算</p><p><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919164658693.png" alt="image-20210919164658693" style="zoom:50%;"></p><h2 id="符号编码实例">5 符号编码实例</h2><h3 id="grefenstette编码方法">Grefenstette编码方法</h3><p><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919165829569.png" alt="image-20210919165829569" style="zoom:50%;"></p><h3 id="部分匹配交叉pmx">部分匹配交叉PMX</h3><ul><li>先随机产生两个交叉点，定义这两点间的区域为匹配区域，交换两个父代的匹配区域</li><li>对于匹配区域外出现的重复编码，要依据匹配区域内的映射关系逐一替换</li></ul><p><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919170133984.png" alt="image-20210919170133984" style="zoom:50%;"></p><h3 id="顺序交叉ox">顺序交叉OX</h3><p><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919170202295.png" alt="image-20210919170202295" style="zoom:67%;"></p><h3 id="循环交叉cx">循环交叉CX</h3><p><img src="/2021/11/13/yi-chuan-suan-fa-xiang-jie/image-20210919170316288.png" alt="image-20210919170316288" style="zoom:67%;"></p><h1 id="遗传算法-matlab-工具箱-ga-实现">遗传算法 MATLAB 工具箱 GA 实现</h1><p>首先 <strong>MATLAB</strong> 的函数 <strong>GA</strong> 的详细说明文档可见</p><p><a href="https://ww2.mathworks.cn/help/gads/ga.html?s_tid=doc_ta#d123e44602">Find minimum of function using genetic algorithm - MATLAB ga - MathWorks 中国</a></p><p>以下主要说明 <strong>GA</strong> 函数的简要调用以及作图方面的注意事项</p><h2 id="ga-的调用">1 GA 的调用</h2><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">[x,fval,exitflag,output,population,scores] = ga(fun,nvars,A,b,Aeq,beq,lb,ub,nonlcon,options)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>输入参数：</strong></p><ul><li><strong>fun：</strong> 目标函数</li><li><strong>nvars：</strong> 变量个数</li><li><strong>A：</strong> 线性不等式约束系数矩阵</li><li><strong>b：</strong> 线性不等式约束系数向量</li><li><strong>Aeq：</strong> 线性等式约束矩阵</li><li><strong>beq：</strong> 线性等式约束向量</li><li><strong>lb：</strong> 下界</li><li><strong>ub：</strong> 上界</li><li><strong>nonlcon：</strong> 非线性约束</li><li><strong>options：</strong> 优化器</li></ul><p><strong>输出参数：</strong></p><ul><li><strong>x：</strong> 最优解</li><li><strong>fval：</strong> 目标函数再最优解下的最小值</li><li><strong>exitflag：</strong> 程序停止的原因<ul><li><strong>1：</strong> 找到最小值</li><li><strong>3：</strong> 在约束没有冲突的情况下找到最小值</li><li><strong>4：</strong> 步长的大小太小，停止运行</li><li><strong>5：</strong> 已到达适应度函数的最小值</li><li><strong>0：</strong> 超出最大迭代次数限制</li><li><strong>-1：</strong> 被优化器的画图函数终止</li><li><strong>-2：</strong> 没有可行点</li><li><strong>-4，-5：</strong> 超出时间限制</li></ul></li><li><strong>output：</strong> 优化器的进程输出</li><li><strong>population：</strong> 最后一代</li><li><strong>scores：</strong> 最后适应度的分数</li></ul><h2 id="ga-options-配置">2 GA options 配置</h2>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>切平面法</title>
      <link href="/2021/11/12/qie-ping-mian-fa/"/>
      <url>/2021/11/12/qie-ping-mian-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="切平面算法">切平面算法</h1><p>切平面算法是对凸函数的一种寻找极值的优化的算法，通过不断的构造平面逼近目标函数来求取极小值</p><h2 id="原理">原理</h2><p>设对于所有属于凸函数定义域（凸集）的 <strong>x</strong> ，目标函数 <strong>f</strong> 也是凸的。</p><p>假设之前已经选取了 <strong>k</strong> 个参数向量 <span class="math inline">\(x_1,x_2,...,x_k\)</span> ，且已经计算了这些点的函数值 <span class="math inline">\(f(x_1),...,f(x_k)\)</span> 以及它们的次梯度 <span class="math inline">\(\nabla f(x_1),...,\nabla f(x_k)\)</span> ，因为函数是凸的，所以这些点的泰勒展开的一次项（次梯度是小于等于当点的梯度），可以得到 <span class="math display">\[f(x) \geq f(x_i) + \nabla f(x_i)(x-x_i)\]</span> （以二阶函数作图示例）</p><figure><img src="/2021/11/12/qie-ping-mian-fa/image-20211112092443719.png" alt="image-20211112092443719"><figcaption aria-hidden="true">image-20211112092443719</figcaption></figure><p>在二次优化中，次梯度就为该点的切线方向</p><p>所以对于凸函数中所有的 <strong>x</strong> 来说，满足以下关系 <span class="math display">\[f(x) \geq \max \ f(x_i) + \nabla^Tf(x_i)(x-x_i)\]</span> 换句话说，目标函数值构成的曲线始终在由次梯度形成的平面组合之上，而对于目标函数的全局最小值 <span class="math display">\[f(x^*) \geq \min_{x}\ \ \max(f(x_i) + \nabla^Tf(x_i)(x-x_i)) = :L_k^*\]</span> 式中所示的<span class="math inline">\(L_k^*\)</span> 为目前所选的参数向量 <span class="math inline">\(x_1,x_2,...,x_k\)</span> 所构成的平面的最小点，即目标函数最优解 <span class="math inline">\(x^*\)</span>的下界，<span class="math inline">\(U_k^*\)</span> 为目前所选的参数向量 <span class="math inline">\(x_1,x_2,...,x_k\)</span> 中函数值最小的点，即目标函数最优解 <span class="math inline">\(x^*\)</span>的上界 <span class="math display">\[U_k^* = \min(f(x_i))\]</span> 所谓切平面法，就是通过不断缩小上界和下界的差距来达到目标函数的最优解 <span class="math inline">\(x^*\)</span></p><p>对于每一步的<span class="math inline">\(L_k^*\)</span> 可以通过以下线性规划来求解 <span class="math display">\[$L_k^* = \min \ L_k \\s.t.\  L_k \geq f(x_i) + \nabla^Tf(x_i)(x-x_i)\]</span> 通过简化，使得此线性规划问题更加容易求解</p><p>定义以下矩阵以及向量 <span class="math display">\[c = \left [ \begin{array}{c}0 \\1\end{array} \right ],w_k = \left [ \begin{array}{c}x \\L_k\end{array} \right ]\\A = \left [ \begin{array}{c}\nabla^Tf(x_1) &amp; -1\\... &amp; ... \\\nabla^Tf(x_i) &amp; -1\end{array} \right ],b = \left [ \begin{array}{c}\nabla^Tf(x_1)x_1 - f(x_1)\\... \\\nabla^Tf(x_i)x_i - f(x_i)\end{array} \right ]\]</span> 则原线性规划问题变为： <span class="math display">\[\min c^Tw_k \\s.t. \ Aw_k \leq b\]</span> 所以每次增加一个迭代点 <span class="math inline">\(x_k\)</span> 都有 <span class="math display">\[U_k^* \geq U_{k+1}^* \geq f(x^*) \geq L_{k+1}^* \geq L_k^*\]</span> 可以不断迭代直到满足条件</p><h2 id="有约束切平面法">有约束切平面法</h2><p>有约束切平面法相比于无约束切平面法，多的是对于求解域加了约束 <span class="math inline">\(g(x)\)</span></p><p>如果将 <span class="math inline">\(g(x)\)</span> 同样用次梯度代替，用平面去逼近 <span class="math inline">\(g(x)\)</span> ，也相当于解另一个线性规划问题，如果将两个线性规划结合，就是有约束的切平面法</p><figure><img src="/2021/11/12/qie-ping-mian-fa/image-20211112101656345.png" alt="image-20211112101656345"><figcaption aria-hidden="true">image-20211112101656345</figcaption></figure><p>对于凸函数 <span class="math inline">\(g(x)\)</span> 的次梯度有 <span class="math display">\[g(x) \geq g(x_i) + \nabla^Tg(x_i)(x - x_i)  \qquad i=1,...,k\]</span> 这就是说， <span class="math display">\[\{x|g(x)\leq0 \} \in \{ x| g(x_i) + \nabla^Tg(x_i)(x - x_i)\} \\\nabla^Tg(x_i)x \leq - g(x_i) + \nabla^Tg(x_i) x_i \qquad i=1,...,i\]</span> 相当于人为的扩大了可行解的范围，当然不一定准确，要经过不断地迭代，缩小切平面逼近的可行解与实际可行解的差距</p><p>将其写入线性规划中有 <span class="math display">\[c = \left [ \begin{array}{c}0 \\1\end{array} \right ],w_k = \left [ \begin{array}{c}x \\L_k\end{array} \right ]\\A = \left [ \begin{array}{c}\nabla^Tf(x_1) &amp; -1\\\nabla^Tg(x_1) &amp; 0\\... &amp; ... \\\nabla^Tf(x_i) &amp; -1 \\\nabla^Tg(x_i) &amp; 0\end{array} \right ],b = \left [ \begin{array}{c}\nabla^Tf(x_1)x_1 - f(x_1)\\\nabla^Tg(x_1)x_1 - g(x_1)\\... \\\nabla^Tf(x_i)x_i - f(x_i) \\ \nabla^Tg(x_i)x_i - g(x_i) \end{array} \right ]\]</span> 不断的迭代求解该线性规划问题，直到误差足够小 <span class="math display">\[U_k^* \geq U_{k+1}^* \geq f(x^*) \geq L_{k+1}^* \geq L_k^*\]</span></p><p>对于某些接近凸函数的区域，仍然可以使用切面算法。但是，如果找到<span class="math inline">\(U_i \leq L_i\)</span> ，可能会在运行算法时遇到一些错误。在这种情况下，必须重新选择一组新的初始向量 <span class="math inline">\(x_1,...x_k\)</span>，在最后找到的 <span class="math inline">\(x_i\)</span> 附近，然后重新开始优化</p><p>具体<strong>MATLAB</strong>实现过程可见代码<a href="https://github.com/xxxxlc/opt/blob/main/matlab_algorithm/cuting_plan.m">opt/cuting_plan.m at main · xxxxlc/opt (github.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二阶非齐次常微分方程的解</title>
      <link href="/2021/10/02/er-jie-fei-qi-ci-chang-wei-fen-fang-cheng-de-jie/"/>
      <url>/2021/10/02/er-jie-fei-qi-ci-chang-wei-fen-fang-cheng-de-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="非齐次线性微分方程">非齐次线性微分方程</h1><h2 id="标准形式">标准形式</h2><p><span class="math display">\[y'' + py' + q = f(x)\]</span></p><p>它的解是由该线性方程的齐次形式的通解，加上非齐次方程的特解组成</p><h2 id="齐次线性方程的通解">齐次线性方程的通解</h2><p>此时方程变为 <span class="math display">\[y''+py'+q = 0\]</span></p><ul><li>若 <span class="math inline">\(p,q\)</span> 全为常数，那么方程为二阶常系数齐次线性微分方程</li><li>若<span class="math inline">\(p,q\)</span> 不全为常数，那么方程为二阶变系数齐次线性微分方程</li></ul><p>定理一：如果函数 <span class="math inline">\(y_1(x)\)</span> 与 <span class="math inline">\(y_2(x)\)</span> 线性无关且是方程的两个解，那么 <span class="math inline">\(y = c_1y_1(x) + c_2y_2(x)\)</span> 也是方程的解</p><ol type="1"><li>写出方程的特征方程 <span class="math inline">\(r^2 + pr + q = 0\)</span></li><li>判断 <span class="math inline">\(p^2-4q\)</span> ，从而决定如何继续求解</li><li>利用求<span class="math inline">\(r_1，r_2\)</span></li></ol><ul><li><p>当 <span class="math inline">\(p^2-4q &gt; 0\)</span> 此时 <span class="math inline">\(r_1\)</span> 和 <span class="math inline">\(r_2\)</span> 为两个不相等的实根 <span class="math display">\[y = C_1e^{r_1x} + C_2e^{r_2x}\]</span></p></li><li><p>当 <span class="math inline">\(p^2-4q = 0\)</span> 此时 <span class="math inline">\(r_1\)</span> 和 <span class="math inline">\(r_2\)</span> 为两个相等的实根 <span class="math display">\[y = e^{r_1x}(C_1 + C_2x)\]</span></p></li><li><p>当 <span class="math inline">\(p^2-4q &lt; 0\)</span> 此时 <span class="math inline">\(r_1\)</span> 和 <span class="math inline">\(r_2\)</span> 为两个不相等的共轭复根 <span class="math display">\[y = e^{\alpha x} (C_1cos\beta x + C_2 sin \beta x) \\\alpha = - \frac{p}{2} \qquad \beta = \frac{\sqrt{4q - p^2}}{2}\]</span></p></li></ul><h2 id="非齐次方程的特解">非齐次方程的特解</h2><p><span class="math display">\[y''+py'+q = f(x)\]</span></p><h3 id="fx-elambda-x-p_mx"><span class="math inline">\(f(x) = e^{\lambda x} P_m(x)\)</span></h3><p>猜测 <span class="math inline">\(y = e^{\lambda x} R(x)\)</span> 为特解，<span class="math inline">\(R(x)\)</span> 是关于 <span class="math inline">\(x\)</span> 的一个多项式</p><p>对所猜测的 <span class="math inline">\(y\)</span> 的解进行求导有 <span class="math display">\[y^* = R(x)e^{\lambda x} \\\Rightarrow y^{*'} = e^{\lambda x}[R'(x) + \lambda R(x)] \\\Rightarrow y^{*''} = e^{\lambda x}[R''(x) + 2\lambda R'(x) + \lambda ^2 R(x)]\]</span> 代入原方程有 <span class="math display">\[R''(x) + (2 \lambda + p)R'(x)+ (\lambda ^ 2 + p \lambda + q)R(x) = P_m(x)\]</span></p><p>如果 <span class="math inline">\(\lambda ^ 2 + p \lambda + q \neq 0\)</span> ，即 <span class="math inline">\(\lambda\)</span> 不是原方程的特征方程 <span class="math inline">\(r^2+pr+q = 0\)</span> 的根，那么这时候 $2+ p  $ 也成立（求导）</p><p>如果想要使得上式方程成立，那么 <span class="math inline">\(R(x)\)</span> 满足 <span class="math display">\[R(x) = b_0x^m + b_1x^{m-1}+...+b_m\]</span> 此时令方程两边 <span class="math inline">\(x\)</span> 的同次幂的系数相等即可</p><p>如果 <span class="math inline">\(\lambda ^ 2 + p \lambda + q = 0\)</span> ，则 <span class="math inline">\(\lambda\)</span> 是 原方程的特征方程 <span class="math inline">\(r^2+pr+q = 0\)</span> 的单根，但是 $2+ p  $ ，此时有： <span class="math display">\[R''(x) + (2 \lambda + p)R'(x) = P_m(x)\]</span> 要是两端相等，<span class="math inline">\(R'(x)\)</span> 必须是 <span class="math inline">\(m\)</span> 次的多项式 <span class="math display">\[R(x) = xR_m(x)\]</span> 同样根据两边 <span class="math inline">\(x\)</span> 的同次幂的系数相等即可<span class="math inline">\(R(x)\)</span></p><p>如果 <span class="math inline">\(\lambda ^ 2 + p \lambda + q = 0\)</span> ，则 <span class="math inline">\(\lambda\)</span> 是 原方程的特征方程 <span class="math inline">\(r^2+pr+q = 0\)</span> 的重根，但是 $2+ p =0 $ ，此时有： <span class="math display">\[R''(x) = P_m(x)\]</span> 则令 <span class="math display">\[R(x) = x^2R_m(x)\]</span></p><h3 id="fx-elambda-x-p_lxcos-omega-x-q_nx-sin-omega-x"><span class="math inline">\(f(x) = e^{\lambda x} P_l(x)\cos \omega x + Q_n(x) \sin \omega x\)</span></h3><p>首先使用欧拉公式进行变形 <span class="math display">\[e^{i \theta} = \cos \theta + i \sin \theta \\\]</span> 可以得到 <span class="math display">\[\cos \theta = \frac{1}{2}(e^{i \theta} + e^{-i \theta}) \\\sin \theta = \frac{1}{2}(e^{i \theta} - e^{-i \theta})\]</span> 代入 <span class="math inline">\(f(x)\)</span> <span class="math display">\[f(x) = (\frac{P_l(x)}{2} + \frac{Q_n(x)}{2i})e^{(\lambda + \omega i)x} + (\frac{P_l(x)}{2} - \frac{Q_n(x)}{2i})e^{(\lambda - \omega i)x}\]</span> 使用共轭函数 <span class="math inline">\(P(x)\)</span> 与 <span class="math inline">\(\bar{P}(x)\)</span> 来表示 <span class="math display">\[P(x) =\frac{P_l(x)}{2} + \frac{Q_n(x)}{2i} = \frac{P_l(x)}{2} + \frac{Q_n(x)}{2}i  \\\bar{P}(x) = \frac{P_l(x)}{2} - \frac{Q_n(x)}{2i} = \frac{P_l(x)}{2} - \frac{Q_n(x)}{2}i  \\\Rightarrow f(x) =P(x) e^{(\lambda + \omega i)x} + \bar{P}(x) e^{(\lambda - \omega i)x}\]</span> 此时方程变为 <span class="math display">\[y''+py'+q =P(x) e^{(\lambda + \omega i)x} + \bar{P}(x) e^{(\lambda - \omega i)x}\]</span> 根据叠加原理，只要分别解出以下两个方程即可</p><p><span class="math display">\[y''+py'+q =P(x) e^{(\lambda + \omega i)x} \\y''+py'+q = \bar{P}(x) e^{(\lambda - \omega i)x}\\\Rightarrow y^* = x^ke^{\lambda x}[R_me^{\omega xi} + \bar{R}_me^{-\omega xi} ]\]</span></p><p>其中 <span class="math inline">\(k\)</span> 按 <span class="math inline">\(\lambda + \omega i\)</span> 不是对应特征方程的根或者是特征方程的单根取0或者1</p><p>再用欧拉公式反代 <span class="math display">\[y^* = x^ke^{\lambda x}[R_m(\cos \omega x+ i \sin \omega x) + \bar{R}_m(\cos \omega x+ i \sin \omega x) ]\]</span> 由于 <span class="math inline">\(R_m\)</span> 与 <span class="math inline">\(\bar{R}_m\)</span> 共轭，相加后不会出现虚部，可以进一步化简为 <span class="math display">\[y^* = x^ke^{\lambda x}[R_m^{(1)}\cos \omega x + R_m^{(2)} \sin \omega x]\]</span></p>]]></content>
      
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora-数学符号</title>
      <link href="/2021/09/14/typora-shu-xue-fu-hao/"/>
      <url>/2021/09/14/typora-shu-xue-fu-hao/</url>
      
        <content type="html"><![CDATA[<figure><img src="/2021/09/14/typora-shu-xue-fu-hao/1.png" alt="1"><figcaption aria-hidden="true">1</figcaption></figure><figure><img src="/2021/09/14/typora-shu-xue-fu-hao/2.png" alt="2"><figcaption aria-hidden="true">2</figcaption></figure><figure><img src="/2021/09/14/typora-shu-xue-fu-hao/3.png" alt="3"><figcaption aria-hidden="true">3</figcaption></figure><figure><img src="/2021/09/14/typora-shu-xue-fu-hao/4.png" alt="4"><figcaption aria-hidden="true">4</figcaption></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python网络数据采集</title>
      <link href="/2021/09/10/python-wang-luo-shu-ju-cai-ji/"/>
      <url>/2021/09/10/python-wang-luo-shu-ju-cai-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="chapter-1-初见网络爬虫">Chapter 1 初见网络爬虫</h1><h2 id="网络连接">1 网络连接</h2><p>python通过urlopen模块进行数据交换</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenhtml = urlopen('url')print(html.read())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>urllib</strong>是一个包，它收集了以下几个用于处理<strong>url</strong>的模块：</p><ul><li><strong>urllib.request</strong> 主要用于打开和读取<strong>URLs</strong></li><li><strong>urllib.error</strong> 包含了由<strong>urllib.request</strong>引发的异常</li><li><strong>urllib.parse</strong> 用于解析<strong>URLs</strong></li><li><strong>urllib.robotparesr</strong> 用于解析<strong>robot.txt</strong>文件</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>data</strong> 必须是一个对象，指定要发送到服务器的附加数据，如果不需要此类数据，则为 <strong>None</strong>。</p><p>其余见<strong>urllib.request</strong>文档：<a href="https://docs.python.org/3/library/urllib.request.html#module-urllib.request">urllib.request — Extensible library for opening URLs — Python 3.9.6 documentation</a></p><p><strong>urllib.error</strong> 通常包含三个异常类：<strong>URLError</strong> 、<strong>HTPPError</strong> 、<strong>ContentTooShortError(msg, content)</strong></p><ul><li><strong>URLError</strong> 通常的错误</li><li><strong>HTPPError</strong> url打不开或者服务器不存在</li><li><strong>ContentTooShortError</strong> 下载量小于预期量时会发生的错误</li></ul><h2 id="beautifulsoup">2 BeautifulSoup</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from bs4 import BeautifulSoup<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导入<strong>BeautifulSoup</strong>，此模块相当于可以将<strong>urllib.request</strong>获取的代码按照标签进行分类，得到如下图所示的效果：</p><figure><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210829085925876.png" alt="image-20210829085925876"><figcaption aria-hidden="true">image-20210829085925876</figcaption></figure><p>然后根据对象的标签的名称就可以进行查找与索引，比如要输出<strong>html</strong>的<strong>h1</strong>：</p><p><strong>bs.h1</strong> 、<strong>bs.html.body.h1</strong> 、<strong>bs.body.h1</strong> 、<strong>bs.html.h1</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://www.pythonscraping.com/pages/page1.html')bs = BeautifulSoup(html.read(), 'html.parser')print(bs.h1)print(bs.html.body.h1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="网络连接的异常">3 网络连接的异常</h2><p>一般来说，<strong>urlopen</strong>函数会出现两种异常</p><ul><li>网页在服务器上不存在，程序会返回<strong>HTTP</strong> 错误</li><li>服务器不存在，<strong>url</strong>会返回一个<strong>None</strong>对象</li></ul><p>对于以上两种情况的处理如下：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:    html = urlopen("https://pythonscrapingthisurldoesnotexist.com")except HTTPError as e:    print("The server returned an HTTP error")except URLError as e:    print("The server could not be found!")else:    print(html.read())if html is None:    print('URL is not found')else:    # 程序继续<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果网页上的内容不像我们期待那样，没法读取所输入的标签，<strong>BeautifulSoup</strong>也会返回一个<strong>None</strong>对象，当调用此对象的子标签时，就会出现<strong>AttributeError</strong>，所以最好的做法是对读取的标签进行检测：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">try:badContent = bsObj.nonExistingTag.anotherTagexcept AttributeError as e: print("Tag was not found")else: if badContent == None: print ("Tag was not found") else: print(badContent)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenfrom urllib.error import HTTPErrorfrom bs4 import BeautifulSoupdef getTitle(url): try: html = urlopen(url) except HTTPError as e: return None         try: bsObj = BeautifulSoup(html.read()) title = bsObj.body.h1 except AttributeError as e: return Nonereturn titletitle = getTitle("http://www.pythonscraping.com/pages/page1.html")if title == None: print("Title could not be found")else: print(title)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="chapter-2-复杂html解析">Chapter 2 复杂HTML解析</h1><p><strong>Cascading Style Sheet，CSS</strong> 层叠样式表</p><p><strong>CSS</strong>可以让<strong>html</strong>的元素呈现差异化，使那些具有完全相同相同修饰的元素具有不同的形式</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>green<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="beautifulsoup-1">1 BeautifulSoup</h2><p>通过<strong>BeautifulSoup</strong>建立的对象<strong>bsObj</strong>，可以通过<strong>findAll</strong>函数进行批量抽取</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://www.pythonscraping.com/pages/warandpeace.html')bs = BeautifulSoup(html, "html.parser")nameList = bs.findAll('span', {'class': 'green'})for name in nameList:    print(name.get_text())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>get_text</strong>函数可以将源码中的超链接、标签、段落全部去掉，只剩下文本内容</p><h3 id="find-和-findall">find() 和 findAll()</h3><ul><li><strong>findAll(tag, attributes, recursive, text, limit, keywords)</strong></li><li><strong>find(tag, attributes, recursive, text, keywords)</strong></li></ul><p><strong>tag：</strong>一个或多个标签名称，<strong>{“h1”，“h2”，“h3”}</strong></p><p><strong>attributes：</strong> 用一个python字典封装一个标签的若干属性和对应的属性， <strong>("span", {"class":{"green", "red"}})</strong></p><p><strong>recursive：</strong> 布尔变量；默认值为<strong>True</strong></p><ul><li><strong>True：</strong> 搜索标签参数的所有子标签</li><li><strong>False：</strong> 只查找文档标签的第一级</li></ul><p><strong>text：</strong> 用标签的文本内容去匹配而不是用标签属性</p><p><strong>limit：</strong> 范围限制，<strong>find</strong>相当于<strong>findAll(limit=1)</strong></p><p><strong>keyword：</strong> 可以选择那些指定属性的标签</p><h3 id="beautifulsoup中的对象">BeautifulSoup中的对象</h3><ul><li><strong>BeautifulSoup</strong>对象，使用<strong>BeautifulSoup</strong>模块转化而成的对象，通常写作<strong>bsObj</strong></li><li>标签<strong>Tag</strong> 对象，通过<strong>find</strong>和<strong>findAll</strong>函数获取的对象，例<strong>bsObj.div.h1</strong></li><li><strong>NavigableString</strong> 对象，表示标签中的文字，而不是标签</li><li><strong>Comment</strong> 对象，用来查找<strong>HTML</strong>文档的注释标签</li></ul><h3 id="导航树">导航树</h3><p><strong>HTML</strong>都可以被映射成为一棵树：</p><figure><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210830083717460.png" alt="image-20210830083717460"><figcaption aria-hidden="true">image-20210830083717460</figcaption></figure><h4 id="子标签和其他后代标签的处理方式">子标签和其他后代标签的处理方式</h4><p>子标签是父标签的下一代，而后代标签则是父标签的所有后代</p><p>一般在<strong>BeautifulSoup</strong>中<strong>find</strong>是找到父标签中出现的第一个标签，而<strong>findAll</strong>函则是在父标签中的所有后代标签中寻找符合条件的标签</p><p>如果只想找出子标签，可以使用<strong>.children</strong>标签</p><p>如果想在所有的后代标签中寻找，可以使用<strong>.descendants</strong>标签</p><h4 id="兄弟标签的处理方式">兄弟标签的处理方式</h4><p><strong>next_siblings()</strong></p><ul><li>寻找的对象不能获取，因为兄弟标签不会包括对象本身，只能调用与对象本身平行的兄弟标签</li><li>兄弟标签只能获取在对象标签本身后面的标签，平行与对象标签但是位于对象标签的前方的标签不能获取</li></ul><h4 id="父标签的处理方式">父标签的处理方式</h4><p><strong>parent()</strong> 可以访问当前标签的父标签</p><p><strong>previous_siblings()</strong> 可以访问当前标签的前一个兄弟标签</p><h2 id="正则表达式">2 正则表达式</h2><figure><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210830090555285.png" alt="image-20210830090555285"><figcaption aria-hidden="true">image-20210830090555285</figcaption></figure><h2 id="beautifulsoup中的正则表达式">3 BeautifulSoup中的正则表达式</h2><p>抓取图片</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenfrom bs4 import BeautifulSoupimport rehtml = urlopen('http://www.pythonscraping.com/pages/page3.html')bs = BeautifulSoup(html, 'html.parser')images = bs.find_all('img', {'src':re.compile('\.\.\/img\/gifts/img.*\.jpg')})for image in images:     print(image['src'])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>src</strong>代表图片的路径属性</p><h2 id="获取属性">4 获取属性</h2><p>使用 <strong>attrs()</strong> 可以获取标签的全部属性</p><p><strong>myTag.attrs</strong></p><h2 id="lambda表达式">5 Lambda表达式</h2><p><strong>Lambda</strong>本质是一个函数，可以作为其他函数的变量使用</p><p><strong>f(g(x), h(x))</strong></p><p>获取具有两个属性的标签</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">bs.find_all(lambda tag: len(tag.attrs) == 2)bs.find_all(lambda tag: tag.get_text() == 'Or maybe he\'s only resting?')bs.find_all('', text='Or maybe he\'s only resting?')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="chapter-3-开始采集">Chapter 3 开始采集</h1><p>网络爬虫：沿着网络爬行</p><h2 id="遍历单个域名">1 遍历单个域名</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenfrom bs4 import BeautifulSoup html = urlopen('http://en.wikipedia.org/wiki/Kevin_Bacon')bs = BeautifulSoup(html, 'html.parser')for link in bs.find_all('a'):    if 'href' in link.attrs:        print(link.attrs['href'])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>bs.find_all('a')</strong></p><p>&lt;a&gt; 标签用来定义超链接</p><p>在<strong>Wiki</strong>中指向词条页面的链接，具有以下三个特点：</p><ul><li>都在<strong>id</strong>是<strong>bodyContent</strong>的<strong>div</strong>标签中</li><li><strong>URL</strong>链接不包含分号</li><li><strong>URL</strong>都以 <strong>/wiki/</strong> 开头</li></ul><p>随机爬行，直到网页上无其他符合条件的连接</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenfrom bs4 import BeautifulSoupimport datetimeimport randomimport rerandom.seed(datetime.datetime.now())def getLinks(articleUrl):    html = urlopen('http://en.wikipedia.org{}'.format(articleUrl))    bs = BeautifulSoup(html, 'html.parser')    return bs.find('div', {'id':'bodyContent'}).find_all('a', href=re.compile('^(/wiki/)((?!:).)*$'))links = getLinks('/wiki/Kevin_Bacon')while len(links) &gt; 0:    newArticle = links[random.randint(0, len(links)-1)].attrs['href']    print(newArticle)    links = getLinks(newArticle)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="采集整个网站">2 采集整个网站</h2><p>使用数据库来储存采集到的资源</p><ul><li>浅网：互联网引擎上可以抓取到的部分</li><li>深网：互联网无法抓取</li><li>暗网：使用<strong>Tor</strong>客户端，带有运行在<strong>HTTP</strong>之上的新协议，提供一个信息交换的安全隧道</li></ul><h3 id="采集整个网站的用途">采集整个网站的用途</h3><ul><li>生成网站地图</li><li>收集数据</li></ul><h3 id="链接去重">链接去重</h3><p>在代码运行时，把已发现的所有链接都放在一起，并保存在方便查询的列表中（<strong>python</strong>的<strong>set</strong>集合）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def getLinks(pageUrl):    global pages    html = urlopen('http://en.wikipedia.org{}'.format(pageUrl))    bs = BeautifulSoup(html, 'html.parser')    for link in bs.find_all('a', href=re.compile('^(/wiki/)')):        if 'href' in link.attrs:            if link.attrs['href'] not in pages:                #We have encountered a new page                newPage = link.attrs['href']                print(newPage)                pages.add(newPage)                getLinks(newPage)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="section"></h5><h3 id="收集整个网站数据">收集整个网站数据</h3><ul><li>所有的标题都是在<strong>h1 -&gt; span</strong>标签中，而且页面只有一个<strong>h1</strong>标签</li><li>所有的正文文字都是在<strong>div#bodyContent</strong>标签中，如果进一步获取文字，可使用<strong>div#mw-content-text -&gt; p</strong></li><li>编辑链接只出现在词条页面上，其都位于<strong>li#ca-edit</strong>标签的<strong>li#ca-edit -&gt; span -&gt; a</strong> 中</li></ul><p>爬虫与数据采集的组合程序</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenfrom bs4 import BeautifulSoupimport repages = set()def getLinks(pageUrl):    global pages    html = urlopen('http://en.wikipedia.org{}'.format(pageUrl))    bs = BeautifulSoup(html, 'html.parser')    try:        print(bs.h1.get_text())        print(bs.find(id ='mw-content-text').find_all('p')[0])        print(bs.find(id='ca-edit').find('span').find('a').attrs['href'])    except AttributeError:        print('This page is missing something! Continuing.')        for link in bs.find_all('a', href=re.compile('^(/wiki/)')):        if 'href' in link.attrs:            if link.attrs['href'] not in pages:                #We have encountered a new page                newPage = link.attrs['href']                print('-'*20)                print(newPage)                pages.add(newPage)                getLinks(newPage)getLinks('') <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通过互联网采集">3 通过互联网采集</h2><h3 id="urlparse-模块介绍">urlparse 模块介绍</h3><p><strong>urlparse</strong> 模块主要用于解析<strong>url</strong>中的参数，对<strong>url</strong>按照一定格式进行拆分或拼接</p><ul><li><strong>urlparse.urlparse</strong></li></ul><p>该函数可将<strong>url</strong>划分为六个部分，返回一个包含6个字符串项目的元组：协议、位置、路径、参数、查询、片段</p><p><strong>parseResult(scheme=, netloc=, path=, params=, quety=, fragment=)</strong></p><p>其中 <strong>scheme</strong> 是协议 <strong>netloc</strong> 是域名服务器 path 相对路径 <strong>params</strong>是参数，<strong>query</strong>是查询的条件</p><ul><li><strong>urlparse.urlsplit</strong></li></ul><p>和<strong>urlparse</strong>函数类似，此函数将<strong>url</strong>分为五个部分：协议、位置、路径、查询、片段</p><ul><li><strong>urlparse.urljoin</strong></li></ul><p>将相对的地址组合成一个url，对于输入没有限制，开头必须是http://，否则将不组合前面。</p><h3 id="采集外链流程图">采集外链流程图</h3><figure><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210902095353833.png" alt="image-20210902095353833"><figcaption aria-hidden="true">image-20210902095353833</figcaption></figure><figure><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210902095535033.png" alt="image-20210902095535033"><figcaption aria-hidden="true">image-20210902095535033</figcaption></figure><h2 id="用scrapy采集">4 用Scrapy采集</h2><p>创建新的<strong>Scrapy</strong>项目</p><p><strong>$scrapy startproject wikiSpider</strong></p><p>创建后文件目录结构：</p><ul><li><strong>scrapy.cfg</strong></li><li><strong>wikiSpider</strong><ul><li>__ <strong>init</strong> __.<strong>py</strong></li><li><strong>items.py</strong></li><li><strong>pipeline.py</strong></li><li><strong>setting.py</strong></li><li><strong>spiders</strong><ul><li>__ <strong>init</strong> __.<strong>py</strong></li></ul></li></ul></li></ul><p><strong>Scrapy</strong>中每个<strong>Itcm</strong>（条目）对象表示网站上的一个页面</p><p>你可以在 <strong>wikiSpider</strong> 主目录中用如下命令运行 <strong>ArticleSpider</strong>：</p><p><strong>$ scrapy crawl article</strong></p><h1 id="chapter-4-使用api">Chapter 4 使用API</h1><p>编程接口 <strong>Application Programming Interface</strong></p><p>为不同的应用提供了方便友好的接口</p><h2 id="api-概述">1 API 概述</h2><p><strong>EPSN</strong>: 提供了运动员信息、比赛分数</p><p><strong>Google</strong>开发者社区 https://console.developers.google.com/ : 提供了获取语言翻译、分析、地理位置等信息</p><p><strong>API</strong> 的请求使用需要非常严谨的语法，而且<strong>API</strong>使用<strong>JSON</strong>或者<strong>XML</strong>格式表示数据，而不是<strong>HTML</strong></p><h2 id="api-通用规则">2 API 通用规则</h2><h3 id="方法">方法</h3><p>利用<strong>HTTP</strong> 从网络服务获取信息的方式有四种：</p><ul><li><strong>GET</strong></li><li><strong>POST</strong></li><li><strong>PUT</strong></li><li><strong>DELETE</strong></li></ul><p><strong>GET</strong>在浏览器中输入网址浏览网站做出的响应</p><p><strong>POST</strong>填写表单或提交信息到网络服务器后端程序时需要做的事情</p><p><strong>PUT</strong>更新一个对象的信息</p><p><strong>DELETE</strong>删除一个对象</p><h3 id="验证">验证</h3><p>通常 API 验证的方法都是用类似令牌 <strong>（token）</strong> 的方式调用，每次 <strong>API</strong> 调用都会把令牌传递到服务器上。这种令牌要么是用户注册的时候分配给用户，要么就是在用户调用的时候才提供，可能是长期固定的值，也可能是频繁变化的，通过服务器对用户名和密码的组合处理后生成。</p><p>令牌除了在 <strong>URL</strong> 链接中传递，还会通过请求头里的 <strong>cookie</strong> 把用户信息传递给服务器。使用<strong>urllib</strong>进行<strong>token</strong>的传递</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">token = "&lt;your api token&gt;"webRequest = urllib.request.Request("http://myapi.com", headers={"token":token})html = urlopen(webRequest)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="服务器响应">3 服务器响应</h2><p><strong>JSON</strong>文件比<strong>XML</strong>文件具有更小的体积，其次因为网络技术的进步，许多服务器技术处理<strong>JSON</strong>比处理<strong>XML</strong>简单。</p><h3 id="api调用">API调用</h3><p>当使用<strong>GET</strong>请求获取数据时，可以使用查询参数作为过滤器或附加请求</p><p>也可通过<strong>URL</strong>的路径指定<strong>API</strong>的版本、数据格式以及其他属性</p><p>还有一些<strong>API</strong>可通过请求参数的形式指定数据格式和<strong>API</strong>版本</p><h2 id="echo-nest">4 Echo Nest</h2><p><strong>The Echo Nest</strong> 音乐数据网站 3 是一个用网络爬虫建立的超级给力的企业级案例</p><h2 id="twitter-api">5 Twitter API</h2><h2 id="google-api">6 Google API</h2><p>可以查看<strong>google</strong>的帮助文档</p><h2 id="结合api及网络数据采集">7 结合API及网络数据采集</h2><h1 id="chapter-5-存储数据">Chapter 5 存储数据</h1><h5 id="需要将数据储存起来分析第五章会介绍三种数据管理方法">需要将数据储存起来分析，第五章会介绍三种数据管理方法</h5><h2 id="媒体文件">1 媒体文件</h2><p>存储媒体文件有两种主要形式：</p><ul><li>获取存储文件的<strong>URL</strong></li><li>直接将源文件下载下来</li></ul><p>通过<strong>URL</strong>链接直接引用的优点：</p><ul><li>运行的更快，耗费流量更少</li><li>节省储存空间</li><li>代码更容易写</li><li>降低目标主机服务器的负载</li></ul><p>缺点：</p><ul><li>内嵌在自己网站或应用中的外站<strong>URL</strong>链接被称为<strong>盗链</strong></li><li><strong>盗链</strong>非常容易改变</li></ul><p>通过<strong>python</strong>中<strong>urllib.resquest.urlretrieve</strong>模块可以根据文件的<strong>URL</strong>下载文件：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlretrievefrom urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://www.pythonscraping.com')bs = BeautifulSoup(html, 'html.parser')imageLocation = bs.find('a', {'id': 'logo'}).find('img')['src']urlretrieve (imageLocation, 'logo.jpg')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="将数据储存在csv文件">2 将数据储存在CSV文件</h2><p>网络数据采集一个常用功能就是获取<strong>HTML</strong>表格写入<strong>CSV</strong>文件</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import csvfrom urllib.request import urlopenfrom bs4 import BeautifulSouphtml = urlopen('http://en.wikipedia.org/wiki/Comparison_of_text_editors')bs = BeautifulSoup(html, 'html.parser')# The main comparison table is currently the first table on the pagetable = bs.findAll('table',{'class':'wikitable'})[0]rows = table.findAll('tr')csvFile = open('editors.csv', 'wt+')writer = csv.writer(csvFile)try:    for row in rows:        csvRow = []        for cell in row.findAll(['td', 'th']):            csvRow.append(cell.get_text())        writer.writerow(csvRow)finally:    csvFile.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="mysql">3 MySQL</h2><p>关系型数据</p><h3 id="安装mysql">安装<strong>MySQL</strong></h3><p><strong>Windows</strong>安装工具http://dev.mysql.com/downloads/windows/installer/</p><h3 id="mysql语法"><strong>MySQL</strong>语法</h3><p>首次登陆<strong>MySQL</strong>，创建数据库：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create database scraping;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>MySQL</strong>的语法必须带有分号</p><p>指定某个特定的数据库使用：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">USE scraping;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建一个表用来储存采集的网页：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">&gt;CREATE TABLE pages (id BIGINT(7) NOT NULL AUTO_INCREMENT, title VARCHAR(200),content VARCHAR(10000), created TIMESTAMP DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY(id));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><figure><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210905100759435.png" alt="image-20210905100759435"><figcaption aria-hidden="true">image-20210905100759435</figcaption></figure><p>在实际存储的过程中只需要存储<strong>title</strong>与<strong>content</strong>两个字段，因为<strong>id</strong>是递增的，而<strong>created</strong>会自动加入时间戳</p><p>选择<strong>id</strong>为2的数据：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from pages where id = 2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选择<strong>title</strong>为<strong>“test”</strong>的数据：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from pages where title like "%test%";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回数据的特定字段</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select id content from pages where content like "%page content%";<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>delete</strong>语法与<strong>select</strong>语法类似</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">delete from pages id = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>update</strong>语法</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">UPDATE pages SET title="A new title", content="Some new content" WHERE id=2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="与python结合">与python结合</h3><p>安装<strong>python</strong>模块：<strong>pymysql</strong></p><p>使数据库支持<strong>Unicode</strong>字符串：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">ALTER DATABASE scraping CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;ALTER TABLE pages CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;ALTER TABLE pages CHANGE title title VARCHAR(200) CHARACTER SET utf8mb4 COLLATEutf8mb4_unicode_ci;ALTER TABLE pages CHANGE content content VARCHAR(10000) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="数据库技术与最佳实践">数据库技术与最佳实践</h3><h2 id="email">4 Email</h2><p>邮件与网页不同，网页是通过<strong>HTTP</strong>协议传输的，邮件是通过<strong>SMTP</strong>协议传输的</p><p>使用<strong>python</strong>发送邮件：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import smtplibfrom email.mime.text import MIMETextmsg = MIMEText('The body of the email is here')msg['Subject'] = 'An Email Alert'msg['From'] = 'ryan@pythonscraping.com'msg['To'] = 'webmaster@pythonscraping.com's = smtplib.SMTP('localhost')s.send_message(msg)s.quit()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="chapter-6-读取文档">Chapter 6 读取文档</h1><p>重点介绍文档处理的相关内容，包扩：</p><ul><li>将文件下载到文件夹</li><li>读取文档提取数据</li><li>文档的不同编码类型</li></ul><h2 id="文档编码">1 文档编码</h2><p>文档编码就是文件读取的规则</p><p>从最底层的角度来看，所有的文档都是由0和1编码而成的。</p><p>体积缩减或者数据压缩算法都是根据编码算法定义：每个字符多少位、每个像素的颜色值用多少位，例如<strong>PNG</strong>图像编码格式就是一种无损压缩的位图图形格式</p><h2 id="纯文本">2 纯文本</h2><p>对于简单的纯文本文件，可以直接读取页面内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopentextPage = urlopen(url)print(textPage.read())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>缺点是不能使用<strong>html</strong>中的标签去定义需要的文字</p><h3 id="文本编码和全球互联网">文本编码和全球互联网</h3><h4 id="编码类型简介">编码类型简介</h4><p><strong>UTF-8</strong>：</p><p><strong>UTF-8</strong> 的每个字符开头有一个标记表示“这个字符只用一个字节”或“那个字符需要用两个字节”，一个字符最多可以是四个字节。由于这四个字节里还包含一部分设置信息，用来决定多少字节用做字符编码，所以全部的 32 位（32 位 =4 字节 ×8 位 / 字 节）并不会都用，其实最多使用 21 位，也就是总共 2 097 152 种可能里面可以有 1 114 112 个字符</p><p><strong>ASCII</strong>:</p><p><strong>ASCII</strong> 是 20 世纪 60 年代开始使用的文字编码标准，每个字符 7 位，一共 27 ，即 128 个字 符。</p><h4 id="编码进行">编码进行</h4><p>将读取到的字符串使用<strong>UTF-8</strong>输出</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print(str(textPage.read(), 'utf-8'))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>在处理<strong>HTML</strong>网页时，大多是网站都会在**<p>**部分显示页面使用的编码格式</p>**<meta charset="utf-8"><p>**</p><h2 id="csv">3 CSV</h2><h3 id="读取csv文件">读取CSV文件</h3><p>一共有三种方法可以读取使用<strong>CSV</strong>文件：</p><ul><li>手动下载<strong>CSV</strong>文件，然后用<strong>python</strong>定义文件位置</li><li>使用<strong>Python</strong>下载<strong>CSV</strong>文件，之后再将源文件删除</li><li>直接将网上的<strong>CSV</strong>文件读成字符串，然后转化为一个<strong>StringIO</strong>对象，使它具有文件属性</li></ul><p>一般使用第三种方法是最节省空间</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenfrom io import StringIOimport csvdata = urlopen('http://pythonscraping.com/files/MontyPythonAlbums.csv').read().decode('ascii', 'ignore')dataFile = StringIO(data)csvReader = csv.reader(dataFile)for row in csvReader:    print(row)    print("The album \""+row[0]+"\" was released in "+str(row[1]))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="csv.dictreader"><strong>csv.DictReader</strong></h4><p><strong>csv.DictReader</strong>会将<strong>CSV</strong>文件的每一行转换为<strong>Python</strong>的字典对象返回，而不是列表对象，此时<strong>CSV</strong>文件中的字段列表则作为字典中的键</p><h2 id="pdf">4 PDF</h2><p>（https://pypi.python.org/pypi/pdfminer3k）</p><h2 id="word和.docx">5 Word和.docx</h2><h1 id="chapter-7-数据清洗">Chapter 7 数据清洗</h1><p>介绍一些工具和技术，通过改变代码的编写方式，帮你 从源头控制数据零乱的问题，并且对已经进入数据库的数据进行清洗</p><h2 id="编写代码清洗数据">1 编写代码清洗数据</h2><p><strong>n-gram</strong>：表示文字或语言中n个连续的单词组成的序列</p><p>如何获得格式合理的<strong>n-gram</strong></p><p>通过建立简单的数据清洗函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def cleanInput(input):    input = re.sub('\n+', " ", input)    input = re.sub('\[[0-9]*\]', "", input)    input = re.sub(' +', " ", input)    input = bytes(input, "UTF-8")    input = input.decode("ascii", "ignore")    cleanInput = []    input = input.split(' ')    for item in input:        item = item.strip(string.punctuation)        if len(item) &gt; 1 or (item.lower() == 'a' or item.lower() == 'i'):            cleanInput.append(item)    return cleanInput<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="数据标准化">数据标准化</h3><p>自动对输入的信息进行清洗，去掉不正确的内容，按照标准格式进行输出</p><p>在<strong>Python</strong>中的<strong>collections</strong>库中有一个有序字典<strong>OrderedDict</strong>可以解决这个问题</p><h2 id="数据存储后再进行清洗">2 数据存储后再进行清洗</h2><h3 id="openrefine">OpenRefine</h3><h1 id="chapter-8-自然语言处理">Chapter 8 自然语言处理</h1><h2 id="概括数据">1 概括数据</h2><p>在上一章中，将文本内容分解成<strong>n-gram</strong>模型，从基本功能上来说，这个集合可以确定这段文字中最常用的单词和短语</p><p>在将文本内容排序之后，可以使用<strong>python</strong>中的<strong>operator</strong>模块对<strong>n-gram</strong>进行排序</p><p>除此之外，可以提取原文中那些最常用的短语周围的句子，对原文进行概括</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from urllib.request import urlopenfrom bs4 import BeautifulSoupimport reimport stringimport operatordef cleanInput(input):    input = re.sub("\n+", " ", input).lower()    input = re.sub('\[[0-9]*\]', "", input)    input = re.sub(' +', " ", input)    input = bytes(input, 'UTF-8')    input = input.decode("ascii", "ignore")    cleanInput = []    input = input.split(" ")    for item in input:        item = item.strip(string.punctuation)        if len(item) &gt; 1 or (item.lower() == 'a' or item.lower() == 'i'):            cleanInput.append(item)        return cleanInputdef isCommon(ngram):    commonWords = ["the", "be", "and", "of", "a", "in", "to", "have", "it",                    "i", "that", "for", "you", "he", "with", "on", "do", "say", "this",                    "they", "is", "an", "at", "but","we", "his", "from", "that", "not",                    "by", "she", "or", "as", "what", "go", "their","can", "who", "get",                    "if", "would", "her", "all", "my", "make", "about", "know", "will",                    "as", "up", "one", "time", "has", "been", "there", "year", "so",                    "think", "when", "which", "them", "some", "me", "people", "take",                    "out", "into", "just", "see", "him", "your", "come", "could", "now",                    "than", "like", "other", "how", "then", "its", "our", "two", "more",                    "these", "want", "way", "look", "first", "also", "new", "because",                    "day", "more", "use", "no", "man", "find", "here", "thing", "give",                    "many", "well"]    for word in ngram:        if word in commonWords:            return True    return Falsedef ngrams(input, n):    input = cleanInput(input)    output = {}    for i in range(len(input)-n+1):        ngramTemp = " ".join(input[i:i+n])        if ngramTemp not in output:            output[ngramTemp] = 0        output[ngramTemp] += 1        return outputcontent = str(urlopen("http://pythonscraping.com/files/inaugurationSpeech.txt").read(),'utf-8')ngrams = ngrams(content, 2)sortedNGrams = sorted(ngrams.items(), key = operator.itemgetter(1), reverse=True)for ngram in sortedNGrams:        if not isCommon(ngram[0].split(" ")):        print(ngram, end=' ')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="马尔可夫模型">2 马尔可夫模型</h2><p>马尔可夫文字生成器（<strong>Markov text generator</strong>）</p><p>这些文字生成器都是基于分析大量随机事件的马尔可夫模型，随机事件的特点是一个离散事件发生之后，另一个离散事件在前一个事件发生的条件下以一定概率发生</p><figure><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210907094611686.png" alt="image-20210907094611686"><figcaption aria-hidden="true">image-20210907094611686</figcaption></figure><p>此系统具有以下特点：</p><ul><li>任何一个节点引出的可能性的总和必须是100%</li><li>只有当前节点会影响后一天的状态</li><li>每个节点接受可能性不同，接受的可能性越小到达此点的可能性越小</li></ul><p><strong>Google 的 page rank 算法</strong></p><p>基于马尔可夫模型， 把网站作为节点，入站和出站链接作为节点之间的连线，而连接某个节点的可能性表示一个网站的相对关注度。</p><h3 id="维基百科六度分割">维基百科六度分割</h3><p>网站之间的连接相当于一个有向图问题</p><p>寻找最短路径的方法：<strong>广度优先搜索</strong></p><h2 id="自然语言工具包">3 自然语言工具包</h2><p><strong>Natural Language Toolkit，NLTK</strong></p><p>其用来识别和标记英语文本中每个词的属性</p><h3 id="安装与设置">安装与设置</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">import nltknltk,download()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>打开<strong>NLTK</strong>的下载器</p><h3 id="使用nltk做统计分析">使用NLTK做统计分析</h3><p><strong>NLTK</strong>的统计对象：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from nltk import word_tokenizefrom nltk import Texttokens = word_tokenize("Here is some not very interesting text")text = Text(tokens)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>NLTK</strong>频率分布对象<strong>FreqDist</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from nltk import FreqDistfdist = FreqDist(text6)fdist.most_common(10)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>2-ngram</strong>模型：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from nltk import bigramsbigrams = bigrams(text6)bigramsDist = FreqDist(bigrams)bigramsDist[("Sir", "Robin")]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="nltk做词性分析">NLTK做词性分析</h3><p>Penn Treebank 语义标记</p><p><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210907110634539.png" alt="image-20210907110634539" style="zoom:50%;"></p><p><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210907110702958.png" alt="image-20210907110702958" style="zoom:50%;"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from nltk import pos_tagpos_tag(text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="chapter-9-穿越网页表单与登录窗口进行采集">Chapter 9 穿越网页表单与登录窗口进行采集</h1><p>通过<strong>POST</strong>请求网页数据</p><h2 id="python-requests-库">1 python requests 库</h2><p><strong>Requests</strong>库就是一个擅长处理那些复杂的<strong>HTTP</strong>请求、<strong>cookies</strong>、header等内容的<strong>python</strong>第三方库</p><p>因为python的标准库 <strong>urllib2</strong> <strong>API</strong>不太行</p><h2 id="提交一个基本的表单">2 提交一个基本的表单</h2><p>网页表单：大多数由一些<strong>HTML</strong>字段、一个提交按钮、一个表单处理完之后跳转的执行结果页面构成。表单的目的只是帮助网站的访问者发送合理的请求，向服务器请求没有出现的页面</p><p>大多数主流网站都会在<strong>robots.txt</strong>文件里注明禁止爬虫接入的登录表单</p><p>表单的真实行为都发生在<strong>processing.php</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsparams = {'firstname': 'Ryan', 'lastname': 'Mitchell'}r = requests.post("http://pythonscraping.com/files/processing.php", data=params)print(r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单选按钮复选框和其他输入">3 单选按钮、复选框和其他输入</h2><p>字段名称和值是用<strong>POST</strong>进行请求的最重要的两个方面的值</p><p>字段名称：可以通过查找源码寻找<strong>name</strong>属性轻易获取</p><p>字段的值：直接看网站的<strong>URL</strong>连接</p><h2 id="提交文件和图像">4 提交文件和图像</h2><p>直接提交，与提交文字没有区别，因为<strong>request.post</strong>有一个<strong>type</strong>选项为<strong>file</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsfiles = {'uploadFile': open('../files/Python-logo.png', 'rb')}r = requests.post("http://pythonscraping.com/pages/processing2.php", files=files)print(r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="处理登录和cookie">5 处理登录和cookie</h2><p>大多数新型网站采用<strong>cookie</strong>跟踪用户是否登录的状态信息</p><p>一旦网站验证了你的登录权证，它就会将它们保存在你的浏览器的 cookie 中，里面通常包含一个服务器生成的令牌、登录有效时限和状态跟踪信息。网站会把这个 <strong>cookie</strong> 当作信息验证的证据，在你浏览网站的每个页面时出示给服务器。</p><p>使用<strong>Requests</strong>库进行跟踪<strong>cookie</strong>：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsparams = {'username': 'Ryan', 'password': 'password'}r = requests.post("http://pythonscraping.com/pages/cookies/welcome.php", params)print("Cookie is set to:")print(r.cookies.get_dict())print("-----------")print("Going to profile page...")r = requests.get("http://pythonscraping.com/pages/cookies/profile.php", cookies=r.cookies)print(r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用<strong>seesion</strong>函数，其能持续的跟踪会话信息，包括<strong>cookie</strong>、<strong>header</strong></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestssession = requests.Session()params = {'username': 'username', 'password': 'password'}s = session.post("http://pythonscraping.com/pages/cookies/welcome.php", params)print("Cookie is set to:")print(s.cookies.get_dict())print("-----------")print("Going to profile page...")s = session.get("http://pythonscraping.com/pages/cookies/profile.php")print(s.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="http基本接入认证">HTTP基本接入认证</h3><p>使用<strong>Requests.auth</strong>模块来处理<strong>HTTP</strong>认证：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import requestsfrom requests.auth import AuthBasefrom requests.auth import HTTPBasicAuthauth = HTTPBasicAuth('ryan', 'password')r = requests.post(url="http://pythonscraping.com/pages/auth/login.php", auth=auth)print(r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="chapter-10-采集javascript">Chapter 10 采集JavaScript</h1><p>通常在客户端的语言只有两种：</p><ul><li>ActionScript</li><li>JavaScript</li></ul><h2 id="javascript-简介">1 JavaScript 简介</h2><p><strong>JavaScript</strong> 是一种弱类型语言，其语法通常可以与 <strong>C++</strong> 和 Java 做对比。虽然语法中的一些元素，比如操作符、循环条件和数组，都与 <strong>C++</strong>、Java 语法很接近，但是 <strong>JavaScript</strong> 的弱类型和脚本形式被一些程序员看成是折磨人的怪兽。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token operator">&lt;</span>script<span class="token operator">&gt;</span><span class="token keyword">function</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">var</span> nextNum <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>nextNum<span class="token operator">+</span><span class="token string">" is in the Fibonacci sequence"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nextNum <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> nextNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">fibonacci</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意 <strong>JavaScript</strong> 里所有的变量都用 <strong>var</strong> 关键词字进行定义</p><p><strong>JavaScript</strong> 还有一个非常好的特性，就是把函数作为变量使用：</p><h3 id="常用的javascript库">常用的<strong>JavaScript</strong>库</h3><p>用 <strong>Python</strong> 执行 <strong>JavaScript</strong> 代码的效率非常低，既费时又费力，尤其是在处理规模较大的 <strong>JavaScript</strong> 代码时。</p><ul><li><strong>jQuery</strong></li><li><strong>Google Analytics</strong></li><li><strong>Google</strong>地图</li></ul><h2 id="ajax和动态html">2 Ajax和动态HTML</h2><p><strong>Ajax</strong> 其实并不是一门语言，而是用来完成网络任务（可以认为 它与网络数据采集差不多）的一系列技术。<strong>Ajax</strong> 全称是 <strong>Asynchronous</strong> <strong>JavaScript</strong> <strong>and</strong> <strong>XML</strong> （异步 <strong>JavaScript</strong> 和 <strong>XML</strong>），网站不需要使用单独的页面请求就可以和网络服务器进行交互 （收发信息）。</p><p>和 <strong>Ajax</strong> 一样，动态 <strong>HTML（dynamic HTML，DHTML）</strong>也是一系列用于解决网络问题的 技术集合。DHTML 是用客户端语言改变页面的 <strong>HTML</strong> 元素（HTML、CSS，或者二者皆 被改变）。比如，页面上的按钮只有当用户移动鼠标之后才出现，背景色可能每次点击都 会改变，或者用一个 <strong>Ajax</strong> 请求触发页面加载一段新内容。</p><p><strong>Python</strong> 解决这个问题只有两种途径：直接从 <strong>JavaScript</strong> 代码里采集内容，或者用 <strong>Python</strong> 的 第三方库运行 <strong>JavaScript</strong>，直接采集你在浏览器里看到的页面。</p><h3 id="在python中使用selenium执行javascript">在python中使用Selenium执行JavaScript</h3><p><strong>Selenium</strong> 可以让浏览器自动加载页面，获取需要的数据，甚至页面截屏，或者判断网站上某些动作是否发生。<strong>Selenium</strong>自己不带浏览器。必须结合第三方浏览器才能使用。</p><p><strong>PhantomJS</strong>（http://phantomjs.org/download.html）：此浏览器会把网站加载到内存并执行JavaScript，但是不会向用户展示网页的图形页面。将<strong>Selenium</strong>与<strong>PhantomJS</strong>结合就能运行一个强大的爬虫了</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from selenium import webdriverimport timedriver = webdriver.PhantomJS(executable_path='')driver.get("http://pythonscraping.com/pages/javascript/ajaxDemo.html")time.sleep(3)print(driver.find_element_by_id('content').text)driver.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<strong>Selenium</strong>可以读取页面加载后三秒的图像</p><h2 id="处理重定向">3 处理重定向</h2><p>客户端重定向是在服务器将页面内容发送到浏览器之前，由浏览器执行 <strong>JavaScript</strong> 完成的页面跳转，而不是服务器完成的跳转。根据具体情况， 服务器端重定向一般都可以轻松地通过 Python 的 urllib 库解决</p><p>我们可以用一种智能的方法来检测客户端重定向是否完成，首先从页面开始加载时就“监视”<strong>DOM</strong> 中的一个元素，然后重复调用这个元素直到 <strong>Selenium</strong> 抛出一个 <strong>StaleElementReferenceException</strong> 异常；也就是说，元素不在页面的 <strong>DOM</strong> 里了，说明这时网站已经跳转</p><h1 id="chapter-11-图像识别与文字处理">Chapter 11 图像识别与文字处理</h1><p>主要搞定图像验证码，或者被做成图像的文字</p><h2 id="ocr库概述">1 OCR库概述</h2><h3 id="pillow">Pillow</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python">from PIL import Image, ImageFilterkitten = Image.open("kitten.jpg")blurryKitten = kitten.filter(ImageFilter.GaussianBlur)blurryKitten.save("kitten_blurred.jpg")blurryKitten.show(<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以利用<strong>Pillow</strong>进行图像预处理，此外<strong>Pillow</strong>还可以完成许多复杂的图像处理工作，详细可见<strong>Pillow</strong>文档：</p><p>http://pillow.readthedocs.org/</p><h3 id="tesseract">Tesseract</h3><p><strong>Tesseract</strong> 是目前公认最优秀、最精确的开源 <strong>OCR</strong> 系统</p><p><strong>Tesseract</strong> 是一个 Python 的命令行工具，不是通过 <strong>import</strong>语句导入的库。安装之后，要用 <strong>tesseract</strong> 命令在 <strong>Python</strong> 的外面运行</p><h3 id="安装tesseract">安装Tesseract</h3><p><strong>Windows</strong>: https://code.google.com/p/tesseract-ocr/downloads/list</p><h2 id="处理格式规范的文字">2 处理格式规范的文字</h2><p>清晰且没有背景色混乱的文字能使用<strong>Tesseract</strong>直接读取：</p><p>$tesseract text.tif textoutput | cat textoutput.txt</p><p>输出结果的第一行是 <strong>Tesseract</strong> 的版本信息，表明它正在运行，后面是图片识别结果 <strong>textoutput.txt</strong> 文件里的内容</p><p>如果文字带有模糊效果，且背景色为渐变色，那么<strong>Tesseract</strong>不能处理这种图片</p><p>遇到这类问题，需要采用python脚本对图片进行处理，通过<strong>Pillow</strong>库可以创建一个阈值过滤器去掉渐变背景色。</p><h3 id="从网站图片中抓取文字">从网站图片中抓取文字</h3><h2 id="读取验证码与训练tesseract">3 读取验证码与训练Tesseract</h2><p>使验证码让机器难以读懂：</p><ul><li>字母+数字</li><li>字母的倾斜程度会迷惑OCR软件</li><li>陌生的手写体</li></ul><h3 id="训练tesseract">训练<strong>Tesseract</strong></h3><p>在线工具：Tesseract OCR Chopper（http://pp19dd.com/tesseract-ocr-chopper/）</p><h2 id="获取验证码提交答案">4 获取验证码提交答案</h2><p>大多数网站生成的验证码图片都具有以下属性：</p><ul><li>它们是服务器端的程序动态生成的图片。验证码图片的 src 属性可能和普通图片不太一 样，但是可以和其他图片一样进行 下载和处理。</li><li>图片的答案存储在服务器端的数据库里。</li><li>很多验证码都有时间限制，如果你太长时间没解决就会失效。虽然这对网络机器人来说不是什么问题，但是如果你想保留验证码的答案一会儿再使用，或者想通过一些方法延长验证码的有效时限，可能很难成功。</li></ul><p>常用的处理方法就是，首先把验证码图片下载到硬盘里，清理干净，然后用 Tesseract 处理 图片，最后返回符合网站要求的识别结果。</p><h1 id="chapter-12-避开采集陷阱">Chapter 12 避开采集陷阱</h1><h2 id="道德规范">1 道德规范</h2><h2 id="让网络机器人看起来像人类用户">2 让网络机器人看起来像人类用户</h2><h3 id="修改请求头">修改请求头</h3><p><strong>requests</strong> 模块还可以设置请求头</p><p><strong>HTTP</strong> 的请求头是在你每次向网络服务器发送请求时，传递的一组属性和配置信息</p><p>以下七个字段被大多数浏览器应用</p><figure><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210908203305001.png" alt="image-20210908203305001"><figcaption aria-hidden="true">image-20210908203305001</figcaption></figure><figure><img src="/2021/09/10/python-wang-luo-shu-ju-cai-ji/image-20210908203317436.png" alt="image-20210908203317436"><figcaption aria-hidden="true">image-20210908203317436</figcaption></figure><p>请求头会改变观看网络世界的方式，最重要的请求头就是<strong>User-Agent</strong>，将其设置为不容易引起怀疑的内容</p><h3 id="合理处理cookie">合理处理cookie</h3><h3 id="时间处理">时间处理</h3><p>尽量保证一次加载页面加载且数据请求最小化</p><p>如果条件允许，尽量为每个页面访问增加一点时间间隔</p><p>过高的采集速度会拖垮网站</p><h2 id="常见表单安全措施">3 常见表单安全措施</h2><p>网络机器人在网站上创建几千个垃圾账号，并给其他所有用户发送垃圾邮件</p><h3 id="隐含输入字段值">隐含输入字段值</h3><p>隐含的字段对浏览器可见对用户不可见，主要用于阻止爬虫自动提交表单</p><p>隐含字段阻止网络数据采集的方式主要有两种：</p><ul><li>第一种是表单上的一个字段可以用服务器生成的随机变量表示，绕开这个问题的最佳方法就是采集表单所在页面上的随机变量，然后再提交表单处理页面</li><li>第二种方式就是蜜罐，如果表单里包含一个具有普通名称的隐含字段（设置 蜜罐圈套），比如“用户名”（<strong>username</strong>）或“邮箱地址”（<strong>email</strong> <strong>address</strong>），设计不太好的网 络机器人往往不管这个字段是不是对用户可见，直接填写这个字段并向服务器提交，这样 就会中服务器的蜜罐圈套。服务器会把所有隐含字段的真实值（或者与表单提交页面的默 认值不同的值）都忽略，而且填写隐含字段的访问用户也可能被网站封杀。</li></ul><h3 id="避免蜜罐">避免蜜罐</h3><p>此字段直接就是不可见的，因为它不可显示到浏览器上，如果填写表单的时候填写了此字段，那么就判断你为机器人，提交无效</p><p>一共有三种方式对用户隐藏</p><ul><li>CSS属性设置为<strong>display：none</strong>，浏览器直接不可见</li><li>通过设置<strong>type</strong>字段为<strong>hidden</strong></li><li>将字段设置位移一段距离到屏幕显示范围以外，用户不可见</li></ul><h2 id="问题检查表">4 问题检查表</h2><ul><li>如果爬虫接受到的网络信息是空白的，可能是<strong>JavaScript</strong>的问题</li><li>在<strong>POST</strong>请求时，核对信息是否正确</li><li>如果有登录异常，检查cookie是否正确被调用</li><li><strong>HTTP</strong>错误或者<strong>403</strong>错误，你已被识别为机器人</li><li>确认你的爬虫速度不能特别快</li><li>修改请求头</li><li>确实没有访问任何人类无法访问的信息或者链接</li><li>联系网管</li></ul><h1 id="chapter-13-用爬虫测试网站">Chapter 13 用爬虫测试网站</h1><p>通过爬虫来完成网站的前端测试</p><h2 id="测试简介">1 测试简介</h2><h3 id="单元测试">单元测试</h3><ul><li>每个单元测试用于测试一个零件（<strong>component</strong>）功能的一个方面，通常一个零件的所有单元测试都集成在同一个类里</li><li>每个单元测试都可以完全独立的运行，不能对其他测试造成干扰</li><li>每个单元测试通常至少包含一个断言</li><li>单元测试与生产代码是分离的</li></ul><h2 id="python的单元测试">2 python的单元测试</h2><p><strong>unittest</strong>单元测试模块，继承<strong>unittest.TestCase</strong>类，就可以实现以下功能：</p><ul><li>为每个单元测试的开始和结束提供<strong>setUp</strong>与<strong>tearDown</strong>函数</li><li>提供不同类型的“断言”语句让测试成功或失败</li><li>把所有以<strong>test_</strong>开头的函数当作单元测试运行，忽略不带<strong>test_</strong>的函数</li></ul><p><strong>unittest</strong>类的<strong>setUpClass</strong>函数只在类初始化阶段运行一次，用来代替<strong>setUp</strong>用来省去不必要的页面加载</p><h2 id="selenium-单元测试">3 Selenium 单元测试</h2><p><strong>python</strong>单元测试与<strong>Selenium</strong>单元测试不同</p><p><strong>Selenium</strong>不要求单元测试必须是类的一个函数，它的<strong>断言</strong>语句不需要括号，测试通过也不会有提示，只有当测试失败时才会有信息提示</p><h2 id="python单元测试与selenium单元测试的选择">4 python单元测试与Selenium单元测试的选择</h2><p><strong>Python</strong> 的单元测试语法严谨冗长，更适合为大多数大型项目写测试，而 <strong>Selenium</strong> 的测试方 式灵活且功能强大，可以成为一些网站功能测试的首选。</p><p><strong>Selenium</strong> 可以轻易地获取网站的信息，而单元测试可以评估这些信 息是否满足通过测试的条件。因此，你没有理由拒绝把 <strong>Selenium</strong> 导入 <strong>Python</strong> 的单元测试， 两者组合是最佳拍档。</p><h1 id="chapter-14-远程采集">Chapter 14 远程采集</h1><h2 id="为什么要用远程服务器">1 为什么要用远程服务器</h2><ol type="1"><li>避免IP地址被封杀</li><li>移植性和可扩展性</li></ol><h2 id="tor代理服务器">2 Tor代理服务器</h2><p>洋葱路由（<strong>The Onion Router</strong>）网络，常用缩写为 Tor，是一种 IP 地址匿名手段。</p><h2 id="远程主机">3 远程主机</h2><h2 id="其他资源">4 其他资源</h2>]]></content>
      
      
      
        <tags>
            
            <tag> reading note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB一次修改全部变量名</title>
      <link href="/2021/08/03/matlab-yi-ci-xiu-gai-quan-bu-bian-liang-ming/"/>
      <url>/2021/08/03/matlab-yi-ci-xiu-gai-quan-bu-bian-liang-ming/</url>
      
        <content type="html"><![CDATA[<h1 id="matlab一次修改全部变量名">MATLAB一次修改全部变量名</h1><p>按下 ctrl + H</p><figure><img src="/2021/08/03/matlab-yi-ci-xiu-gai-quan-bu-bian-liang-ming/1.png" alt="image-20210803100819916"><figcaption aria-hidden="true">image-20210803100819916</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/07/27/hello-world/"/>
      <url>/2021/07/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>VSCode</title>
      <link href="/2021/07/26/vscode/"/>
      <url>/2021/07/26/vscode/</url>
      
        <content type="html"><![CDATA[<h1 id="vscode使用方法汇总">VSCode使用方法（汇总）</h1><h2 id="vscode安装">VSCode安装</h2><p>进入VSCode官网进行下载</p><p><a href="https://code.visualstudio.com/Download">Download Visual Studio Code - Mac, Linux, Windows</a></p><figure><img src="/2021/07/26/vscode/图1.png" alt="图1"><figcaption aria-hidden="true">图1</figcaption></figure><p>需要注意：<strong>User Installer</strong>用户安装是只为当前用户安装VSCode，当其他用户登录该电脑时无法使用VSCode；而<strong>System Installe</strong>r系统安装则是可以在C盘根目录安装VSCode，该电脑的所有用户都可使用VSCode。</p><p>在安装过程一路next即可，在安装路径可以选择修改，添加路径<strong>Add PATH</strong>必选。</p><h2 id="vscode配置git">VSCode配置Git</h2><ul><li><p>下载<strong>Git</strong>：<a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p></li><li><p>在<strong>Github</strong>：<a href="https://github.com/">GitHub</a>中申请账号，设置个人的用户名以及邮箱</p></li><li><p>在<strong>Git</strong>终端设置远程Github的用户名以及邮箱<img src="/2021/07/26/vscode/图2.png" alt="图2" style="zoom:80%;"></p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git config --global user.name "your name" git config --global user.email "your@email.com"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>创建<strong>SSHkey</strong></p><pre class="line-numbers language-git" data-language="git"><code class="language-git">ssh-keygen -t rsa -C "your@email.com"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在输入此命令之后，会在本地用户文件生成.ssh文件夹，里面包含id_rsa和id_rsa.pub两个文件。</p></li><li></li></ul><h2 id="vscode插件推荐">VSCode插件推荐</h2><h2 id="vscode-选择编译器">VScode 选择编译器</h2><p>使用快捷键</p><p><strong>Ctrl + Shift + P</strong></p><p>搜索 <strong>Python: Select Interpreter</strong> 进入<strong>Python</strong>解释器选择界面</p><p>在选择框内选择需要的环境</p><figure><img src="/2021/07/26/vscode/image-20210831221818960.png" alt="image-20210831221818960"><figcaption aria-hidden="true">image-20210831221818960</figcaption></figure><h2 id="如何打开setting.json">如何打开Setting.json</h2><p>左下角设置 -&gt; 设置 -&gt; 文本编辑器 -&gt; 在setting.json中编辑</p><p><a href="https://jingyan.baidu.com/article/4f7d571273f3ba5a201927c8.html">新版vscode如何打开settings.json-百度经验 (baidu.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Software Installation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB Coding style</title>
      <link href="/2021/07/17/matlab-coding-style/"/>
      <url>/2021/07/17/matlab-coding-style/</url>
      
        <content type="html"><![CDATA[<h1 id="matlab-编程风格指南">MATLAB 编程风格指南</h1><p>如何写出整洁、干净、可读性高的MATLAB代码，这是一个从开始就必须认真思考的问题，干净整洁的代码风格可以帮助我们更好的维护、理解、共享，同时它也更加容易调试与修改，也伴随着更少的错误。</p><p>作为一个从事于工程领域的学生，MATLAB软件是科研生活中不可缺少的计算软件，但是由于MATLAB是面向过程的编程语言，在编写代码的过程中，有些时候为了方便而产生的变量会使整个程序变得混乱，不适当的编写代码块也使得代码的可读性变得很差，尤其是做大型计算的时候，有时候因为代码过于混乱在调用前面变量时会出现错误。所以对于一些大型的计算程序，干净整洁可读性强的代码风格是很重要的。</p><p>本文列举了一些比较通用实践效果较好的代码风格建议。<span class="github-emoji"><span> </span><img src="https://github.githubassets.com/images/icons/emoji/bowtie.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="命名规则">1 命名规则</h2><h3 id="变量">变量</h3><p>变量的命名必须记录变量的用途以及意义，增加代码的可读性，以便后续对代码的维护。</p><p>在这个地方推荐<strong>CODELF</strong>，在你不知道为变量命名的时候，可以在这个网站进行搜索，可以找到适合变量的命名</p><p><strong>CODEDL</strong>：<a href="https://unbug.github.io/codelf/#root">root - CODELF (unbug.github.io)</a></p><p>其他要求：</p><ol type="1"><li><p>变量名必须以小写开头，大小写混合组合；其次可以用下划线分割复合变量名的各个部分（注意在<strong>MATLAB</strong>图例变量中下划线 _ 会被读取为下标切换）</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">linearity, credibleThreat, qualityOfLifelinearity, credible_Threat, quality_Of_Life<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>作用域较大的变量必须具有有意义的名称，作用域范围小的变量可以拥有较短的名称，比如整数的临时变量：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">i, j, k, m, n, x, y, z<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>前缀<strong>n</strong>通常用来表示对象的数量，而在<strong>MATLAB</strong>中也用<strong>m</strong>表示行数，例如：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">nFiles, n_element, mRows<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>将所有变量名设为单数或者复数，如果为了避免单数复数只有最后的后缀s不同而难以分辨，可以采用后缀<strong>Array</strong>来表示复数：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">points, point, pointArray<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>表示单个临时变量可以以<strong>i</strong>为前缀：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">iPoint, iTable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>迭代器的临时变量应该用<strong>i，j，k</strong>命名：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">for iPoint = 1:nPoint:end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>bool</strong>变量应加上<strong>is</strong>或者<strong>not</strong>的前缀：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">isAnimal, notAnimal<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>首字母缩略词，即使其通常采用大写表示，在变量命名时也该使用小写：</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>避免使用关键词或者特殊名称作为变量名。</p></li></ol><p>合适的变量名称是程序可读性高的基础。</p><h3 id="常数">常数</h3><p>常数的命名比较特殊，应该遵循以下两个原则：</p><ol type="1"><li><p>命名常量应该全部使用大写字母，且使用下划线进行语义分割。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">MAX_PATH_LENGTH<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>尽量使用较多的信息说明常量的意义。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">COLOR_RED<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="结构体类">结构体（类）</h3><ol type="1"><li><p>类的名称应该用大写开头，来区别于变量。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">Dense, Model<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>类的名称不应该被包含在类的成员里面。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">Model.layer<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="函数">函数</h3><p>函数的名称应该含有自身用途的信息。</p><ol type="1"><li><p>函数名应该全部使用小写字母。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">call, compute<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>函数名必须是有意义的名字。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">plotpoint， maxlen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>如果函数只有一个单个的输出，可以用输出参数命名。</p></li><li><p>没有输出参数的函数应该用函数的用途进行命名。</p></li><li><p>前缀<strong>get、set</strong>通常保留用于访问后者设置对象的属性。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">getobj(), get_length<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>前缀<strong>compute</strong>也常被用于函数的命名当中。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">computeweight()computespread()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>前缀<strong>find</strong>通常被用于查找类函数的命名当中。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">findmaxlength()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>前缀<strong>initialize</strong>被用于对象或者概念被建立和初始化参数时。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">initializebias<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>前缀<strong>is</strong>通常被用于<strong>bool</strong>函数。</p></li><li><p>避免出现相同的函数名称，这样在调用函数的时候会出现错误。</p></li></ol><h3 id="通用规则">通用规则</h3><ol type="1"><li>变量和常量的名称通常带有表示单复数的后缀。</li><li>避免命名中的缩写，除非是人尽皆知的缩写，后期检查不利于维护代码。</li><li>所有的命名都应该使用英文。</li></ol><h2 id="文件和结构">2 文件和结构</h2><p>在文件之间和文件内的代码构建十分重要，对于后期维护和理解代码有着很大的帮助，对代码的分区与排序是关键。</p><h3 id="m文件">M文件</h3><ol type="1"><li><p>模块化，编写大程序的最佳方法就是将设计好的小模块组装起来， 这样可以减少查看代码正在做什么时候的代码阅读量。长度超过两个编辑器屏幕的代码最好进行分区处理。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">%% 分区 1code%% 分区 2code<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>函数交互清晰明确，函数通过输入和输出与其他代码进行交互， 尽量避免使用全局变量或者非常多的输入参数。</p></li><li><p>分区，所有的子函数和函数只需要解决一个问题，避免一个体量庞大的函数产生。</p></li><li><p>尽可能使用已经建立好的函数，一个函数可以由多个子函数构成，所以开发一个正确且可读性高、灵活的函数是一项重要的任务。</p></li><li><p>出现在多个<strong>M</strong>文件的代码块都应该被封装成为一个函数。</p></li><li><p>子函数，仅由一个其他函数使用的函数应作为其子函数打包在同一文件中， 这使得代码更易于理解和维护。</p></li><li><p>测试脚本，为每一个函数编写一个测试脚本。这种做法将提高代码的质量和更改版本的可靠性。</p></li></ol><h3 id="输出与输出文件">输出与输出文件</h3><ol type="1"><li>制作输入输出模块， 提高代码的可维护性。</li><li>格式化输出以方便使用。</li></ol><h2 id="声明">3 声明</h2><h3 id="变量和常量">变量和常量</h3><ol type="1"><li><p>除非内存限制需要，否则不应该重复使用变量， 通过确保唯一表示概念来提高代码的可读性， 从而减少因误解定义而出错的机会。</p></li><li><p>可以在同一行声明相同类型的变量， 不应该在同一行中声明不相关的变量。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">float x, y, zglobal LENGTH, MAX_POINT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>一定要在文件的开头附近注释重要变量的意义，包括输入输出参数。</p></li><li><p>在变量声明的同一行末尾可以记录变量的意义。</p><pre class="line-numbers language-matalb" data-language="matalb"><code class="language-matalb">THRESHOLD = 10;    % Maximum noise level found by experiment<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="全局声明">全局声明</h3><ol type="1"><li>应该尽可能地减少使用全局变量， 代码和程序的可维护性受益于参数的传递而不是过多的使用全局变量，一些全局变量可以用持久变量persistent代替。</li><li>应尽可能减少使用全局常量，可以使用特定的M文件或者mat文件来定义常量的值，可以有效的避免无效定义。</li></ol><h3 id="循环">循环</h3><ol type="1"><li><p>循环变量应该在循环之前立即初始化，第一提高了循环的速度，第二防止循环索引出现错误。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">for i = 1:1:n:end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>应该尽量减少在循环中使用<strong>continue</strong>和<strong>break</strong>，其可能会破坏程序的结构。</p></li><li><p>在嵌套循环的结束行应该有注释，用来阐明哪些语句在哪些循环中执行了哪些任务。</p></li></ol><h3 id="条件">条件</h3><ol type="1"><li><p>应该避免复杂的条件表达式，而是使用临时的逻辑变量，更易于阅读或者调试。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">isVaild = (value &gt;= lowerLimit) &amp; (value &lt;= upperLimit);isNew = ~ismember(value, valueArray)if (isVaild &amp; isNew):end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通常的情况应该放在if部分，而异常情况一般放在<strong>if else</strong>或者<strong>else</strong>部分，这种做法主要防止异常遮挡正常的程序执行路径。</p></li><li><p>条件表达式 <strong>if 0</strong> 不应该被使用。</p></li><li><p>switch 语句应该包含其他条件，如果遗漏会导致意想不到的结果。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">switch (condition):case Astatement;case Bstatement;otherswisestatement;end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>switch 变量通常为字符串，字符串在这种情况下表现得更好。</p></li></ol><h3 id="通用规则-1">通用规则</h3><ol type="1"><li><p>首先第一个，避免神秘代码，不要写自己接下来看不懂得代码，使得代码的可维护性变得很差，如果看不懂的代码也应该及时给予注释解释其含义。</p></li><li><p>使用括号，虽然<strong>MATLAB</strong>有运算符优先级的判定，但是加上括号使得逻辑表达式更加清晰。</p></li><li><p>尽量减少在表达式中使用数字， 可更改的数字通常应命名为常量，更改常量比更改文件中所有的相关的数字文本要容易很多。</p></li><li><p>浮点数常量应该在小数点前写一个数字。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">NUMBER = 0.5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>浮点数的比较大小应该慎重。</p></li></ol><h2 id="布局注释文档">4 布局、注释、文档</h2><h3 id="布局">布局</h3><p>布局的目的是帮助读者阅读理解代码， 缩进特别有助于解释结构问题。</p><ol type="1"><li><p>每个文件的代码应保持在<strong>80</strong>列左右，<strong>80</strong> 列是编辑器、终端仿真器、打印机和调试器的通用尺寸，多人共享的文件应保持在这些限制范围内。如果在程序员之间传递文件时避免了无意的换行，则可读性会提高。</p></li><li><p>行应该被点分开，一般而言，应在逗号或者空格后换行，或者运算符号后换行，新行与上一行表达式的开头对齐。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">totalSum = a + b + c + ...   d + e;fuction = (param1, param2, ...           param3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>基本的缩进应使用<strong>Tab</strong>进行缩进。</p></li><li><p>一般来说一行语句只包含一个可执行语句。</p></li><li><p>简单的单个语句<strong>if</strong>、<strong>for</strong>、或<strong>while</strong>语句可以写在一行上面。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">if (condition), statement; endwhile (condition), statement; endfor i = 1:n, statement; end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="空格">空格</h3><p>空格可以使语句看上去漂亮整齐可读性高。</p><ol type="1"><li><p>在运算符号前后都使用空格。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">simpleAverage = (first + last) / 2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在逗号后面可以使用空格。</p></li><li><p>一行中多个命令的分号或者逗号应跟一个空格。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">if (condition), statement; end<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>关键词后面可以跟上一个空格， 可以帮助辨别函数的关键词。</p></li><li><p>一个代码块内的逻辑语句应该用空行分割。</p></li><li><p>在任何地方尽量使用对齐。</p><pre class="line-numbers language-matlab" data-language="matlab"><code class="language-matlab">totalSum = a + b + c + ...   d + e;fuction = (param1, param2, ...           param3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="注释">注释</h3><p>注释的目的是向代码添加信息。注释的典型用途是解释用法、提供参考信息、证明决策的合理性、描述限制、提及需要的改进。经验表明，最好在编写代码的同时编写注释，而不是打算稍后添加注释。</p><ol type="1"><li>注释写的不好，代码也就不好。</li><li>注释应与代码表达的意思一致，但不仅仅是重述代码。</li><li>注释应该通俗易懂。</li><li>注释通常与所引用的语句具有相同的缩进。除了函数的头注释，其余依照<strong>Matlab</strong>自带竖线进行注释。<img src="/2021/07/17/matlab-coding-style/image-20210730093946573.png" alt="image-20210730093946573"></li><li>函数开头的注释应该支持help和<strong>lookfor</strong>函数。</li><li>函数开头注释应该讨论对输入参数的任何特殊要求。</li><li>函数头注释应该描述任何作用。</li><li>一般来说，最后一行函数头注释应该重述函数行，这允许用户浏览帮助打印输出并查看输入和输出参数用法。</li><li>标题注释和其余注释之间应该有一个空行，这样它们就不会在响应帮助时显示出来。</li><li>所有评论应以英文书写。</li></ol><h3 id="文档">文档</h3><ol type="1"><li>README 文档，有用的文档应该包括对代码应该做什么（要求）、它如何工作（设计）、它依赖哪些功能以及它如何被其他代码使用（接口）以及它如何进行测试的可读描述.对于额外的信用，文档可以包括对替代解决方案的讨论以及扩展或维护的建议。</li><li>考虑先编写文档，一些程序员认为最好的方法是“先编码，然后回答问题”。通过经验，我们大多数人了解到开发设计然后实施它会导致更令人满意的结果。开发项目几乎从未如期完成。如果将文档和测试留到最后，它们将被缩短。首先编写文档可确保完成并可能会减少开发时间。</li><li>变化，管理和记录代码更改的专业方法是使用源代码控制工具。对于非常简单的项目，在函数文件中添加更改历史注释肯定比没有好。</li></ol><p><img src="/2021/07/17/matlab-coding-style/1.jpg" alt="1" style="zoom:20%;"></p>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown写法</title>
      <link href="/2020/10/12/markdown/"/>
      <url>/2020/10/12/markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown-用法">Markdown 用法</h1><p>写在前面，在写blog忘记的时候可以回来看看 <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>[Toc]</p><h2 id="标题">1. 标题</h2><p><br> 标题是划分文章整体结构的最好方法，整洁的标题使得文章更为整洁，标题等级越小，则字号越大</p><pre class="line-numbers language-none"><code class="language-none">一号标题 #<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="一号标题">一号标题</h1><p>一号标题主要用于整篇文章的题目 </p><pre class="line-numbers language-none"><code class="language-none">二号标题 ##<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> ## 二号标题 正文的题目开始使用的标题大小 <pre class="line-numbers language-none"><code class="language-none">三号标题 ###<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> ### 三号标题 <pre class="line-numbers language-none"><code class="language-none">四号标题 ####<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> #### 四号标题 <pre class="line-numbers language-none"><code class="language-none">五号标题 #####<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> ##### 五号标题 <pre class="line-numbers language-none"><code class="language-none">..............<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h2 id="分割线">2. 分割线</h2><h2 id="section"><pre class="line-numbers language-none"><code class="language-none">---***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></h2><h2 id="斜体和粗体">3. 斜体和粗体</h2><pre class="line-numbers language-none"><code class="language-none">* 斜体 *** 粗体 ***** 斜体 ***~~要删除的文字~~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><em>斜体</em><br><strong>粗体</strong><br><strong><em>斜体+粗体</em></strong><br><del>要删除的文字</del></p><h2 id="引用">4. 引用</h2><pre class="line-numbers language-none"><code class="language-none">&gt;:........<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>:这是一个引用 ## 5. 表格 Markdown支持有序列表和无序列表，任何表格在建立的时候，序号和内容之间都应该有一个空格 ### 5.1 无序表格 </p><pre class="line-numbers language-none"><code class="language-none">- 列表内容+ 列表内容* 列表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> - 列表内容 + 列表内容 * 列表内容<p></p></blockquote><h3 id="有序表格">5.2 有序表格</h3><pre class="line-numbers language-none"><code class="language-none">1. 列表内容2. 列表内容3. 列表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol type="1"><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><h3 id="列表嵌套">5.3 列表嵌套</h3><p>列表上一级与下一级之间敲三个空格 </p><pre class="line-numbers language-none"><code class="language-none">* 一级无序列表内容   * 二级无序列表内容   * 二级无序列表内容   * 二级无序列表内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre> * 一级无序列表内容<p></p><ul><li>二级无序列表内容</li><li>二级无序列表内容</li><li>二级无序列表内容</li></ul><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符</p><h2 id="表格">6. 表格</h2><pre class="line-numbers language-none"><code class="language-none">表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>表格确实有点麻烦<span class="github-emoji"><span>😵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f635.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 表头|表头|表头 ---|:--:|---: 内容|内容|内容 内容|内容|内容</p><h2 id="代码">7. 代码</h2><h3 id="多行代码">7.1 多行代码</h3><pre class="line-numbers language-none"><code class="language-none">```### 7.2 单行代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>这里是<code>xxxxlc</code> </p><pre class="line-numbers language-none"><code class="language-none">`xxxxlc`## 8. 超链接### 8.1 页内跳转<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre> <a href="#jump">点击跳转</a> <pre class="line-numbers language-none"><code class="language-none">[点击跳转](#jump)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> <span id="jump">跳转此处<span> <pre class="line-numbers language-none"><code class="language-none">&lt;span id="jump"&gt;跳转此处&lt;span&gt;### 8.2 页外跳转<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> <a href="超链接">超链接名</a> <pre class="line-numbers language-none"><code class="language-none">[Github](https://github.com/)### 8.3 参考式超链接参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre> This is [an example][id] reference-style link. <pre class="line-numbers language-none"><code class="language-none">接着，在文件的任意处，你可以把这个标记的链接内容定义出来:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre> [id]: http://example.com/ "Optional Title Here" <pre class="line-numbers language-none"><code class="language-none">### 8.4 自动链接Markdown 还支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用尖括号包起来， Markdown 就会自动把它转成链接。 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre> <a href="https://github.com/" class="uri">https://github.com/</a> <pre class="line-numbers language-none"><code class="language-none">&lt;https://github.com/&gt;## 9 图片### 9.1 行内式图片语法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre> <img src="/2020/10/12/markdown/图片的路径" alt="图片的代替文字"> ```</span></span><p></p><p>https://www.webfx.com/tools/emoji-cheat-sheet/ https://zhuanlan.zhihu.com/p/99319314</p><figure><img src="https://raw.githubusercontent.com/xxxxlc/image/main/picture/test.jpg" alt="test"><figcaption aria-hidden="true">test</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/xxxxlc/image/img/test.png" alt="test"><figcaption aria-hidden="true">test</figcaption></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo具体用法</title>
      <link href="/2020/10/12/hexo-ju-ti-yong-fa/"/>
      <url>/2020/10/12/hexo-ju-ti-yong-fa/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Start !!!</title>
      <link href="/2020/07/16/start/"/>
      <url>/2020/07/16/start/</url>
      
        <content type="html"><![CDATA[<p>始于足下</p><figure><img src="/2020/07/16/start/start.jpg" alt="start"><figcaption aria-hidden="true">start</figcaption></figure>]]></content>
      
      
      
        <tags>
            
            <tag> mood </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
